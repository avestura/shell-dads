{
  "ω": {
    "definition": "A theoretical measure of the execution of an algorithm, usually the time or memory needed, given the problem size n, which is usually the number of items.  Informally, saying some equation f(n) = ω (g(n)) means g(n) becomes insignificant relative to f(n) as n goes to infinity.",
    "alsoKnownAs": null,
    "text": "ω"
  },
  "Ω": {
    "definition": "A theoretical measure of the execution of an algorithm, usually the time or memory needed, given the problem size n, which is usually the number of items.  Informally, saying some equation f(n) = Ω (g(n)) means it is more than some constant multiple of g(n).",
    "alsoKnownAs": null,
    "text": "Ω"
  },
  "ρ-approximation algorithm": {
    "definition": "An approximation algorithm guaranteed to find a solution at most (or at least, as appropriate) ρ times the optimum. The ratio ρ is the performance ratio or relative performance guarantee of the algorithm.",
    "alsoKnownAs": null,
    "text": "ρ-approximation algorithm"
  },
  "∼": {
    "definition": "(1) Proportional to.  (2) Asymptotically equal to.  A theoretical measure of the execution of an algorithm, usually the time or memory needed, given the problem size n, which is usually the number of items.  Informally, saying some equation f(n) ∼ g(n) means it grows at the same rate as g(n). More formally, it means  limx → ∞f(x)/g(x) = 1.",
    "alsoKnownAs": null,
    "text": "∼"
  },
  "Θ": {
    "definition": "A theoretical measure of the execution of an algorithm, usually the time or memory needed, given the problem size n, which is usually the number of items.  Informally, saying some equation f(n) = Θ (g(n)) means it is within a constant multiple of g(n).  The equation is read, \"f of n is theta g of n\".",
    "alsoKnownAs": "asymptotically tight bound, theta.",
    "text": "Θ"
  },
  "absolute performance guarantee": {
    "definition": "An approximation algorithm will return a solution at most a bounded amount more (or less, as appropriate) than the optimum.",
    "alsoKnownAs": null,
    "text": "absolute performance guarantee"
  },
  "abstract data type": {
    "definition": "A set of data values and associated operations that are precisely specified independent of any particular implementation.",
    "alsoKnownAs": "ADT.",
    "text": "abstract data type"
  },
  "(a,b)-tree": {
    "definition": "A search tree with the restrictions that all leaves are at the same depth and all internal nodes have between a and b children, where a and b are integers such that  2 ≤ a ≤ (b+1)/2.   The root may have as few as 2 children.",
    "alsoKnownAs": null,
    "text": "(a,b)-tree"
  },
  "accepting state": {
    "definition": "If a finite state machine finishes an input string and is in an accepting state, the string is accepted or considered to be valid.",
    "alsoKnownAs": null,
    "text": "accepting state"
  },
  "Ackermann's function": {
    "definition": "A function of two parameters whose value grows very fast.",
    "alsoKnownAs": null,
    "text": "Ackermann's function"
  },
  "active data structure": {
    "definition": "A data structure with an associated thread or process that performs internal operations to give the external behavior of another, usually more general, data structure.",
    "alsoKnownAs": "functional data structure.",
    "text": "active data structure"
  },
  "acyclic graph": {
    "definition": "A graph with no path that starts and ends at the same vertex.",
    "alsoKnownAs": null,
    "text": "acyclic graph"
  },
  "adaptive heap sort": {
    "definition": "A variant of heapsort that uses a  randomized binary search tree (RBST) to structure the input according to any preexisting order.  The RBST is used to select candidates that are put into the heap so the heap doesn't need to  keep track of all elements.",
    "alsoKnownAs": null,
    "text": "adaptive heap sort"
  },
  "adaptive Huffman coding": {
    "definition": "A near-minimal variable-length character coding that changes based on the frequency of characters processed.  As characters are processed, frequencies are updated and codes are changed (or, the coding tree is modified).",
    "alsoKnownAs": "dynamic Huffman coding.",
    "text": "adaptive Huffman coding"
  },
  "adaptive k-d tree": {
    "definition": "A tree for multidimensional points where successive levels may be split along different dimensions.",
    "alsoKnownAs": null,
    "text": "adaptive k-d tree"
  },
  "adaptive sort": {
    "definition": "A sorting algorithm that can take advantage of existing order in the input, reducing its requirements for computational resources as a function of the disorder in the input.",
    "alsoKnownAs": null,
    "text": "adaptive sort"
  },
  "address-calculation sort": {
    "definition": "A sort algorithm which uses knowledge of the domain of the items to calculate the position of each item in the sorted array.",
    "alsoKnownAs": null,
    "text": "address-calculation sort"
  },
  "adjacency-list representation": {
    "definition": "A representation of a directed graph with n vertices using an array of n lists of vertices.  List i contains vertex j if there is an edge from vertex i to vertex j.  A weighted graph may be represented with a list of vertex/weight pairs.  An undirected graph may be represented by having vertex j in the list for vertex i and vertex i in the list for vertex j.",
    "alsoKnownAs": null,
    "text": "adjacency-list representation"
  },
  "adjacency-matrix representation": {
    "definition": "A representation of a directed graph with n vertices using an n × n matrix, where the entry at (i,j) is 1 if there is an edge from vertex i to vertex j; otherwise the entry is 0.  A weighted graph may be represented using the weight as the entry.  An undirected graph may be represented using the same entry in both (i,j) and (j,i) or using an upper triangular matrix.",
    "alsoKnownAs": null,
    "text": "adjacency-matrix representation"
  },
  "adjacent": {
    "definition": "Two vertices of a graph are adjacent if there is an edge between them.  Two edges of a graph are adjacent if they connect the same vertex.",
    "alsoKnownAs": null,
    "text": "adjacent"
  },
  "adversary": {
    "definition": "A theoretical agent that uses information about the past moves of an on-line algorithm to choose inputs that force the worst-case cost of the algorithm.",
    "alsoKnownAs": null,
    "text": "adversary"
  },
  "Aho-Corasick": {
    "definition": "A multiple string matching algorithm that constructs a  finite state machine from a pattern (list of keywords), then uses the machine to locate all occurrences of the keywords in a body of text.",
    "alsoKnownAs": null,
    "text": "Aho-Corasick"
  },
  "algorithm": {
    "definition": "A computable set of steps to achieve a desired result.",
    "alsoKnownAs": null,
    "text": "algorithm"
  },
  "algorithm FGK": {
    "definition": "An adaptive Huffman coding scheme.  Coding is never much worse than twice optimal.",
    "alsoKnownAs": null,
    "text": "algorithm FGK"
  },
  "all pairs shortest path": {
    "definition": "Find the weight (or length) of the shortest paths between all pairs of vertices in a weighted, directed graph.",
    "alsoKnownAs": null,
    "text": "all pairs shortest path"
  },
  "all simple paths": {
    "definition": "Find all simple paths from a starting vertex (source) to a destination vertex (sink) in a directed graph.  In an undirected graph, find all simple paths between two vertices.",
    "alsoKnownAs": null,
    "text": "all simple paths"
  },
  "alphabet": {
    "definition": "The set of all possible symbols in an application.  For instance, input characters used by a finite state machine, letters making up strings in a language, or symbols in a pattern element. In some cases, an alphabet may be infinite.",
    "alsoKnownAs": null,
    "text": "alphabet"
  },
  "alternating path": {
    "definition": "A path with alternating free and matched edges.",
    "alsoKnownAs": null,
    "text": "alternating path"
  },
  "alternating Turing machine": {
    "definition": "A nondeterministic Turing machine having universal states, from which the machine accepts only if all possible moves out of that state lead to acceptance.",
    "alsoKnownAs": null,
    "text": "alternating Turing machine"
  },
  "alternation": {
    "definition": "A model of computation proposed by A. K. Chandra, L. Stockmeyere, and D. Kozen, which has two kinds of states, AND and OR.  The definition of accepting computation is adjusted accordingly.",
    "alsoKnownAs": null,
    "text": "alternation"
  },
  "American flag sort": {
    "definition": "An efficient, in-place variant of radix sort that distributes items into hundreds of buckets.   The first step counts the number of items in each bucket, and the second step computes where each bucket will start in the array.  The last step cyclically permutes items to their proper bucket.  Since the buckets are in order in the array, there is no collection step. The name comes by analogy with the Dutch national flag problem in the last step: efficiently partition the array into many \"stripes\". Using some efficiency techniques, it is twice as fast as quicksort for large sets of strings.",
    "alsoKnownAs": null,
    "text": "American flag sort"
  },
  "amortized cost": {
    "definition": "The theoretical speed of a given set of operations.  It is O(f(n)) when the execution time of the worst case of all sequences of n operations never exceeds O(n*f(n)).",
    "alsoKnownAs": null,
    "text": "amortized cost"
  },
  "ancestor": {
    "definition": "A parent of a node in a tree, the parent of the parent, etc.",
    "alsoKnownAs": null,
    "text": "ancestor"
  },
  "and": {
    "definition": "Conjunction: 0 AND 0 = 0, 0 AND 1 = 0, 1 AND 0 = 0, 1 AND 1 = 1.",
    "alsoKnownAs": null,
    "text": "and"
  },
  "ANSI": {
    "definition": "American National Standards Institute.",
    "alsoKnownAs": null,
    "text": "ANSI"
  },
  "antichain": {
    "definition": "A subset of mutually incomparable elements in a poset.",
    "alsoKnownAs": null,
    "text": "antichain"
  },
  "antisymmetric": {
    "definition": "A binary relation R for which a R b and b R a implies a = b.",
    "alsoKnownAs": null,
    "text": "antisymmetric"
  },
  "approximation algorithm": {
    "definition": "An algorithm to solve an optimization problem that runs in polynomial time in the length of the input and outputs a solution that is guaranteed to be close to the optimal solution.  \"Close\" has some well-defined sense called the performance guarantee.",
    "alsoKnownAs": null,
    "text": "approximation algorithm"
  },
  "arborescence": {
    "definition": "Informally, a directed tree.",
    "alsoKnownAs": null,
    "text": "arborescence"
  },
  "arithmetic coding": {
    "definition": "A minimal variable-length message coding based on the frequency of each character.  The message is represented by a fraction which is the repeated offset-plus-product reduction of the range (offset) and probability (product) of each character.",
    "alsoKnownAs": null,
    "text": "arithmetic coding"
  },
  "array": {
    "definition": "An assemblage of items that are randomly accessible by integers, the index.",
    "alsoKnownAs": null,
    "text": "array"
  },
  "array index": {
    "definition": "The location of an item in an array.",
    "alsoKnownAs": null,
    "text": "array index"
  },
  "array merging": {
    "definition": "Joining two arrays into one.",
    "alsoKnownAs": null,
    "text": "array merging"
  },
  "array search": {
    "definition": "Find an element in an array.  Various algorithms exist which require more or less structure in the array elements or implementation.",
    "alsoKnownAs": null,
    "text": "array search"
  },
  "assignment problem": {
    "definition": "The problem of finding a maximum (or minimum) weight matching in a weighted, bipartite graph.",
    "alsoKnownAs": "marriage problem.",
    "text": "assignment problem"
  },
  "associative": {
    "definition": "A function where f(A, f(B, C)) = f(f(A, B), C).",
    "alsoKnownAs": null,
    "text": "associative"
  },
  "associative array": {
    "definition": "A collection of items that are randomly accessible by a key, often a string.",
    "alsoKnownAs": null,
    "text": "associative array"
  },
  "asymptotic bound": {
    "definition": "A curve representing the limit of a function.  That is, the distance between a function and the curve tends to zero.  The function may or may not intersect the bounding curve.",
    "alsoKnownAs": null,
    "text": "asymptotic bound"
  },
  "asymptotic space complexity": {
    "definition": "The limiting behavior of the use of memory space of an algorithm when the size of the problem goes to infinity.  This is usually denoted in big-O notation.",
    "alsoKnownAs": null,
    "text": "asymptotic space complexity"
  },
  "asymptotic time complexity": {
    "definition": "The limiting behavior of the execution time of an algorithm when the size of the problem goes to infinity.  This is usually denoted in big-O notation.",
    "alsoKnownAs": null,
    "text": "asymptotic time complexity"
  },
  "augmenting path": {
    "definition": "A path with alternating free and matched edges that begins and ends with free vertices. Used to augment (improve or increase) a matching or flow.",
    "alsoKnownAs": null,
    "text": "augmenting path"
  },
  "average case": {
    "definition": "Having to do with the mathematical average of all cases.",
    "alsoKnownAs": null,
    "text": "average case"
  },
  "average-case cost": {
    "definition": "The sum of costs of an algorithm over all possible inputs divided by the number of possible inputs.",
    "alsoKnownAs": null,
    "text": "average-case cost"
  },
  "AVL tree": {
    "definition": "A balanced binary search tree where the height of the two subtrees (children) of a node differs by at most one. Look-up, insertion, and deletion are O(log n), where n is the number of nodes in the tree.",
    "alsoKnownAs": null,
    "text": "AVL tree"
  },
  "axiomatic semantics": {
    "definition": "Defining the behavior of an abstract data type with axioms.",
    "alsoKnownAs": null,
    "text": "axiomatic semantics"
  },
  "backtracking": {
    "definition": "Find a solution by trying one of several choices.  If the choice proves incorrect, computation backtracks or restarts at the point of choice and tries another choice.  It is often convenient to maintain choice points and alternate choices using recursion.",
    "alsoKnownAs": null,
    "text": "backtracking"
  },
  "bag": {
    "definition": "An unordered collection of values that may have duplicates.",
    "alsoKnownAs": "multi-set.",
    "text": "bag"
  },
  "balance": {
    "definition": "The (weight) balance of a tree is the number of leaves of the left subtree of a tree, denoted |Tl|, divided by the total number of leaves of the tree.  Formally, ρ(T)  = |Tl|/|T|.",
    "alsoKnownAs": "root balance.",
    "text": "balance"
  },
  "balanced binary search tree": {
    "definition": "A binary search tree that is balanced.",
    "alsoKnownAs": null,
    "text": "balanced binary search tree"
  },
  "balanced binary tree": {
    "definition": "A binary tree where no leaf is more than a certain amount farther from the root than any other.  After inserting or deleting a node, the tree may rebalanced with rotations.",
    "alsoKnownAs": null,
    "text": "balanced binary tree"
  },
  "balanced k-way merge sort": {
    "definition": "A merge sort that sorts a data stream using repeated merges.  It distributes the input into k streams by repeatedly reading a block of input that fits in memory, called a run, sorting it, then writing it to the next stream.  It then repeatedly merges the k streams and puts each merged run into one of j output streams until there is a single sorted output.",
    "alsoKnownAs": null,
    "text": "balanced k-way merge sort"
  },
  "balanced merge sort": {
    "definition": "A k-way merge sort in which the number of input and  output data streams is the same.  See balanced k-way merge sort.",
    "alsoKnownAs": null,
    "text": "balanced merge sort"
  },
  "balanced quicksort": {
    "definition": "A variant of quicksort which attempts to choose a pivot likely to represent the middle of the values to be sorted.",
    "alsoKnownAs": null,
    "text": "balanced quicksort"
  },
  "balanced tree": {
    "definition": "A tree where no leaf is much farther away from the  root than any other leaf.  Different balancing schemes allow different definitions of \"much farther\" and different amounts of work to keep them balanced.",
    "alsoKnownAs": null,
    "text": "balanced tree"
  },
  "balanced two-way merge sort": {
    "definition": "A balanced k-way merge sort that sorts a data stream using repeated merges.  It distributes the input into two streams by repeatedly reading a block of input that fits in memory, a run, sorting it, then writing it to the next stream.  It then repeatedly merges the two streams and puts each merged run into one of two output streams until there is a single sorted output.",
    "alsoKnownAs": null,
    "text": "balanced two-way merge sort"
  },
  "BANG file": {
    "definition": "A balanced and nested grid (BANG) file is a point access method that divides space into a nonperiodic grid.  Each spatial dimension is divided by a  linear hash.  Cells may intersect, and points may be distributed between them.",
    "alsoKnownAs": null,
    "text": "BANG file"
  },
  "Baum Welch algorithm": {
    "definition": "An algorithm to find hidden Markov model parameters A, B, and Π with the maximum likelihood of generating the given symbol sequence in the observation vector.",
    "alsoKnownAs": null,
    "text": "Baum Welch algorithm"
  },
  "BB(α) tree": {
    "definition": "A binary tree where the balance of every subtree,  ρ(T'), is bounded by α ≤ ρ(T') ≤ 1-α.",
    "alsoKnownAs": "weight-balanced tree.",
    "text": "BB(α) tree"
  },
  "BBP algorithm": {
    "definition": "Compute the nth hexadecimal digit of π efficiently, without having to compute preceding digits.",
    "alsoKnownAs": null,
    "text": "BBP algorithm"
  },
  "BDD": {
    "definition": "A binary lattice data structure that succinctly represents a truth table by collapsing redundant nodes and eliminating unnecessary nodes.",
    "alsoKnownAs": null,
    "text": "BDD"
  },
  "BD-tree": {
    "definition": "A binary tree that organizes multidimensional points by splitting off regular subintervals.",
    "alsoKnownAs": null,
    "text": "BD-tree"
  },
  "Bellman-Ford algorithm": {
    "definition": "An efficient algorithm to solve the single-source shortest-path problem. Weights may be negative.   The algorithm initializes the distance to the source vertex to 0 and all other vertices to ∞.  It then does V-1 passes (V is the number of vertices) over all edges relaxing, or updating, the distance to the destination of each edge. Finally it checks each edge again to detect negative weight cycles, in which case it returns false.  The time complexity is O(VE), where E is the number of edges.",
    "alsoKnownAs": "Ford-Bellman.",
    "text": "Bellman-Ford algorithm"
  },
  "Benford's law": {
    "definition": "On a wide variety of statistical data, the first digit is d with the probability log10 ( 1 +  1/d  ).",
    "alsoKnownAs": null,
    "text": "Benford's law"
  },
  "best case": {
    "definition": "(1) The situation or input for which an algorithm or data structure takes the least time or resources. (2) Having to do with this situation or input.",
    "alsoKnownAs": null,
    "text": "best case"
  },
  "best-case cost": {
    "definition": "The minimum cost to process an input sequence.",
    "alsoKnownAs": "optimal cost.",
    "text": "best-case cost"
  },
  "best-first search": {
    "definition": "A state-space search algorithm that considers the estimated best partial solution next.  This is typically implemented with a priority queue.",
    "alsoKnownAs": null,
    "text": "best-first search"
  },
  "biconnected component": {
    "definition": "A maximal subset of edges of a connected graph such that the corresponding induced subgraph cannot be disconnected by deleting any vertex.",
    "alsoKnownAs": null,
    "text": "biconnected component"
  },
  "biconnected graph": {
    "definition": "A connected graph that is not broken into disconnected pieces by deleting any single vertex (and incident edges).",
    "alsoKnownAs": null,
    "text": "biconnected graph"
  },
  "bidirectional bubble sort": {
    "definition": "A variant of bubble sort that compares each adjacent pair of items in a list in turn, swapping them if necessary, and alternately passes through the list from the beginning to the end then from the end to the beginning. It stops when a pass does no swaps.",
    "alsoKnownAs": "cocktail shaker sort, shaker sort, double-direction bubble sort.",
    "text": "bidirectional bubble sort"
  },
  "big-O notation": {
    "definition": "A theoretical measure of the execution of an algorithm, usually the time or memory needed, given the problem size n, which is usually the number of items.  Informally, saying some equation f(n) = O(g(n)) means it is less than some constant multiple of g(n).     The notation is read, \"f of n is big oh of g of n\".",
    "alsoKnownAs": "O, asymptotic upper bound.",
    "text": "big-O notation"
  },
  "binary function": {
    "definition": "A function with two arguments.",
    "alsoKnownAs": null,
    "text": "binary function"
  },
  "binary GCD": {
    "definition": "Compute the greatest common divisor of two integers, u and v, expressed in binary.  The run time complexity is O((log2 u v)²) bit operations.",
    "alsoKnownAs": null,
    "text": "binary GCD"
  },
  "binary heap": {
    "definition": "A complete binary tree where every node has a key more extreme (greater or less) than or equal to the key of its  parent.",
    "alsoKnownAs": null,
    "text": "binary heap"
  },
  "binary insertion sort": {
    "definition": "Insertion sort in which the proper location for the next item is found with a binary search.",
    "alsoKnownAs": null,
    "text": "binary insertion sort"
  },
  "binary priority queue": {
    "definition": "A priority queue implemented with a binary tree having the following restrictions:",
    "alsoKnownAs": null,
    "text": "binary priority queue"
  },
  "binary relation": {
    "definition": "A relation between exactly two items at a time, such as \"greater than\" (>), \"not equal to\" (≠), \"proper subset of\" (⊂), or \"is connected to\" (has an edge to) for vertices of a graph.",
    "alsoKnownAs": null,
    "text": "binary relation"
  },
  "binary search": {
    "definition": "Search a sorted array by repeatedly dividing the search interval in half.  Begin with an interval covering the whole array. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half.  Otherwise narrow it to the upper half.  Repeatedly check until the value is found or the interval is empty.",
    "alsoKnownAs": null,
    "text": "binary search"
  },
  "binary search tree": {
    "definition": "A binary tree where every node's left  subtree has keys less than the node's key, and every right subtree has keys greater than the node's key.",
    "alsoKnownAs": null,
    "text": "binary search tree"
  },
  "binary tree": {
    "definition": "A tree with at most two children for each  node.",
    "alsoKnownAs": "dyadic tree.",
    "text": "binary tree"
  },
  "binary tree representation of trees": {
    "definition": "A way to represent a multiway tree as a binary tree.  The leftmost child, c, of a node, n, in the multiway tree is the left child, c', of the corresponding node, n', in the binary tree. The immediately right sibling of c is the right child of c'.",
    "alsoKnownAs": "first child-next sibling binary tree, doubly-chained tree, filial-heir chain.",
    "text": "binary tree representation of trees"
  },
  "bingo sort": {
    "definition": "A variant of selection sort that orders items by first finding the least value, then repeatedly moving all items with that value to their final location and find the least value for the next pass.  This is more efficient than selection sort if there are many duplicate values.",
    "alsoKnownAs": null,
    "text": "bingo sort"
  },
  "binomial heap": {
    "definition": "A heap made of a forest of binomial trees with the heap property numbered k=0, 1, 2, …, n, each containing either 0 or 2k nodes. Each tree is formed by linking two of its predecessors, by joining one at the root of the other.  The operations of insert a value, decrease a value, delete a value, and merge or join (meld) two queues take O(log n) time.  The find minimum operation is a constant Θ(1).",
    "alsoKnownAs": null,
    "text": "binomial heap"
  },
  "binomial tree": {
    "definition": "An ordered tree of order k ≥ 0, that is Bk, whose root has k children where the ith child is binomial tree of order k-i.",
    "alsoKnownAs": null,
    "text": "binomial tree"
  },
  "bin packing problem": {
    "definition": "Determine how to put the most objects in the least number of fixed space bins.  More formally, find a partition and assignment of a set of objects such that a constraint is satisfied or an objective function is minimized (or maximized). There are many variants, such as, 3D, 2D, linear, pack by volume, pack by weight, minimize volume, maximize value, fixed shape objects, etc.",
    "alsoKnownAs": null,
    "text": "bin packing problem"
  },
  "bintree": {
    "definition": "A regular decomposition k-d tree for region data.",
    "alsoKnownAs": null,
    "text": "bintree"
  },
  "bipartite graph": {
    "definition": "An undirected graph where vertices can be partitioned into two sets such that no edge connects vertices in the same set.",
    "alsoKnownAs": null,
    "text": "bipartite graph"
  },
  "bipartite matching": {
    "definition": "(1) A perfect matching between vertices of a bipartite graph, that is, a subgraph that pairs every vertex with exactly one other vertex. (2) The problem of finding such a matching.",
    "alsoKnownAs": "maximum bipartite matching.",
    "text": "bipartite matching"
  },
  "bisector": {
    "definition": "For two elements ei and ej, the locus of points equidistant from ei and ej.  That is {p|d(p,ei)=d(p(ej)}, where d is some distance metric.",
    "alsoKnownAs": null,
    "text": "bisector"
  },
  "bitonic sort": {
    "definition": "Compare, and swap if necessary, pairs of elements in parallel. Subsets are sorted then merged.",
    "alsoKnownAs": "Batcher sort.",
    "text": "bitonic sort"
  },
  "bit vector": {
    "definition": "An array of bits.",
    "alsoKnownAs": null,
    "text": "bit vector"
  },
  "Bk tree": {
    "definition": "A binomial tree of order (height) k.",
    "alsoKnownAs": null,
    "text": "Bk tree"
  },
  "blind sort": {
    "definition": "A specialized sort algorithm that first builds a blind trie, then traverse the tree left to right.",
    "alsoKnownAs": null,
    "text": "blind sort"
  },
  "blind trie": {
    "definition": "A specialized Patricia tree whose internal nodes store only an integer, k, which is the length of the common prefix of the strings in the children.  Equivalently, the strings first differ in the (k+1)st character.",
    "alsoKnownAs": null,
    "text": "blind trie"
  },
  "block": {
    "definition": "(1) A number of items which are handled together for efficiency. (2) A sequence of don't care symbols.",
    "alsoKnownAs": null,
    "text": "block"
  },
  "block addressing index": {
    "definition": "An inverted index that includes the block, or general location, within texts, in addition to the text in which the word appears.",
    "alsoKnownAs": null,
    "text": "block addressing index"
  },
  "blocking flow": {
    "definition": "A flow function in which any directed path from the source to the sink contains a saturated edge.",
    "alsoKnownAs": null,
    "text": "blocking flow"
  },
  "Bloom filter": {
    "definition": "A data structure with a probabilistic algorithm to quickly test membership in a  large set using multiple hash functions into a single  array of bits.",
    "alsoKnownAs": null,
    "text": "Bloom filter"
  },
  "blossom": {
    "definition": "An odd length cycle which appears during a matching algorithm on general graphs.",
    "alsoKnownAs": null,
    "text": "blossom"
  },
  "bogosort": {
    "definition": "A terribly inefficient sort algorithm that repeatedly generates a random permutation of the items until the items are in order.",
    "alsoKnownAs": null,
    "text": "bogosort"
  },
  "Bond Sequential Search": {
    "definition": "Search an array or list for two keys at once by using the bitwise or of the keys as the search key.  When a possible match is found, compare each key against the item.",
    "alsoKnownAs": null,
    "text": "Bond Sequential Search"
  },
  "boolean": {
    "definition": "(1) In computer science, entities having just two values: 1 or 0, true or false, on or off, etc. along with the operations and, or, and not. (2) In mathematics, entities from an algebra equivalent to intersection, union, and complement over subsets of a given set.",
    "alsoKnownAs": null,
    "text": "boolean"
  },
  "boolean expression": {
    "definition": "An expression consisting solely of boolean variables and values and boolean operations, such as and, or, not, implies, etc.",
    "alsoKnownAs": null,
    "text": "boolean expression"
  },
  "boolean function": {
    "definition": "A function whose range is {0, 1}.  It can be understood to evaluate the truth or falsity of each element of its domain.",
    "alsoKnownAs": null,
    "text": "boolean function"
  },
  "border": {
    "definition": "A string v which is both a prefix and a suffix of another string u.  String v is the border of u if it is the longest proper border of u.",
    "alsoKnownAs": null,
    "text": "border"
  },
  "Boruvka's algorithm": {
    "definition": "Compute a minimum spanning tree.",
    "alsoKnownAs": null,
    "text": "Boruvka's algorithm"
  },
  "bottleneck traveling salesman": {
    "definition": "Find a tour where no edge is more costly than some (bottleneck) amount.",
    "alsoKnownAs": null,
    "text": "bottleneck traveling salesman"
  },
  "boundary-based representation": {
    "definition": "A representation of a region that is based on its boundary.",
    "alsoKnownAs": null,
    "text": "boundary-based representation"
  },
  "bounded queue": {
    "definition": "A queue limited to a fixed number of items.",
    "alsoKnownAs": null,
    "text": "bounded queue"
  },
  "bounded stack": {
    "definition": "A stack limited to a fixed number of items.",
    "alsoKnownAs": null,
    "text": "bounded stack"
  },
  "Boyer-Moore": {
    "definition": "A string matching algorithm that compares characters from the end of the pattern to its beginning.  When characters don't match, searching jumps to the next possible match: the farthest of a table like that used in the Knuth-Morris-Pratt algorithm and the next matching position in the pattern.",
    "alsoKnownAs": null,
    "text": "Boyer-Moore"
  },
  "Boyer-Moore-Horspool": {
    "definition": "A string matching algorithm that compares characters from the end of the pattern to its beginning.  When characters don't match, searching jumps to the next matching position in the pattern.",
    "alsoKnownAs": "Horspool.",
    "text": "Boyer-Moore-Horspool"
  },
  "bozo sort": {
    "definition": "A terribly inefficient sort algorithm that randomly swaps items until they are in order.",
    "alsoKnownAs": null,
    "text": "bozo sort"
  },
  "B+-tree": {
    "definition": "A B-tree in which keys are stored in the  leaves.",
    "alsoKnownAs": null,
    "text": "B+-tree"
  },
  "BPP": {
    "definition": "The class of languages for which a membership computation by a probabilistic Turing machine halts in polynomial time with the right answer (accept or reject) at least 2/3 of the time. \"BPP\" means \"Bounded error Probability in Polynomial\" time.",
    "alsoKnownAs": "bounded error probability in polynomial time.",
    "text": "BPP"
  },
  "Bradford's law": {
    "definition": "Journals in a field can be divided into three parts, each with about one-third of all articles: 1) a core of a few journals, 2) a second zone, with more journals, and 3) a third zone, with the bulk of journals.  The number of journals is 1:n:n².",
    "alsoKnownAs": null,
    "text": "Bradford's law"
  },
  "branch and bound": {
    "definition": "An algorithmic technique to find the optimal solution by keeping the best solution found so far.  If a partial solution cannot improve on the best, it is abandoned.",
    "alsoKnownAs": null,
    "text": "branch and bound"
  },
  "breadth-first search": {
    "definition": "Any search algorithm that considers neighbors of a vertex, that is, outgoing edges of the vertex's predecessor in the search, before any outgoing edges of the vertex.  Extremes are searched last.  This is typically implemented with a queue.",
    "alsoKnownAs": null,
    "text": "breadth-first search"
  },
  "Bresenham's algorithm": {
    "definition": "An efficient algorithm to render a line with pixels.  The long dimension is incremented for each pixel, and the fractional slope is accumulated.",
    "alsoKnownAs": null,
    "text": "Bresenham's algorithm"
  },
  "bridge": {
    "definition": "An edge of a connected graph whose removal would make the graph unconnected.",
    "alsoKnownAs": null,
    "text": "bridge"
  },
  "British Museum technique": {
    "definition": "Find a solution by checking all possibilities one by one, beginning with the smallest.  This is a conceptual, not a practical, technique where the number of possibilities are enormous.",
    "alsoKnownAs": null,
    "text": "British Museum technique"
  },
  "brute force": {
    "definition": "An algorithm that inefficiently solves a problem, often by trying every one of a wide range of possible solutions.",
    "alsoKnownAs": null,
    "text": "brute force"
  },
  "brute force string search": {
    "definition": "Find a string in another string or body of text by trying each position one at a time.  There are many far faster string matching algorithms.",
    "alsoKnownAs": "naive string search.",
    "text": "brute force string search"
  },
  "brute force string search with mismatches": {
    "definition": "Beginning with the (leftmost) position in a string and trying each position in turn, find the number of characters for which the pattern and the substring beginning at that position don't match (the Hamming distance).  Return the first position with k or fewer mismatches.",
    "alsoKnownAs": null,
    "text": "brute force string search with mismatches"
  },
  "BSP-tree": {
    "definition": "A binary space partitioning (BSP) tree is a binary tree for multidimensional points where successive levels are split by arbitrary hyperplanes.",
    "alsoKnownAs": null,
    "text": "BSP-tree"
  },
  "B*-tree": {
    "definition": "A B-tree in which nodes are kept 2/3 full by redistributing keys to fill two child nodes, then splitting them into three nodes.",
    "alsoKnownAs": null,
    "text": "B*-tree"
  },
  "B-tree": {
    "definition": "A balanced search tree in which every node has between ⌈ m/2⌉ and m children, where m>1 is a fixed integer.  m is the order.  The root may have as few as 2 children. This is a good structure if much of the tree is in slow memory (disk), since the height, and hence the number of accesses, can be kept small, say one or two, by picking a large m.",
    "alsoKnownAs": "balanced multiway tree.",
    "text": "B-tree"
  },
  "bubble sort": {
    "definition": "Sort by comparing each adjacent pair of items in a list in turn, swapping the items if necessary, and repeating the pass through the list until no swaps are done.",
    "alsoKnownAs": "sinking sort, exchange sort.",
    "text": "bubble sort"
  },
  "bucket": {
    "definition": "An area of storage where items with a common property are stored. Typically tree data structures and sort algorithms use many buckets, one for each group of items.  Usually buckets are kept on disk.",
    "alsoKnownAs": null,
    "text": "bucket"
  },
  "bucket array": {
    "definition": "Implementation of a dictionary by an array indexed by the keys of the items in the dictionary.",
    "alsoKnownAs": null,
    "text": "bucket array"
  },
  "bucketing method": {
    "definition": "Data organization methods that decompose the space from which spatial data is drawn into regions called buckets. Some conditions for the choice of region boundaries include the number of objects that they contain or on their spatial layout (e.g. minimizing overlap or coverage).",
    "alsoKnownAs": null,
    "text": "bucketing method"
  },
  "bucket sort": {
    "definition": "A distribution sort where input elements are initially  distributed to several buckets based on an interpolation of the element's key. Each bucket is sorted if necessary, and the buckets' contents are concatenated.",
    "alsoKnownAs": "bin sort.",
    "text": "bucket sort"
  },
  "bucket trie": {
    "definition": "A variant of a trie in which leaf nodes are buckets which hold up to k strings.  Usually implies fixed sized buckets.",
    "alsoKnownAs": null,
    "text": "bucket trie"
  },
  "buddy system": {
    "definition": "A memory allocation strategy which recursively divides allocatable blocks of memory into pairs of adjacent equal-sized blocks called \"buddies\".",
    "alsoKnownAs": null,
    "text": "buddy system"
  },
  "buddy tree": {
    "definition": "A point access method which splits multidimensional space in different dimensions at each level.  It also keeps a minimum bounding box of points accessible by each node.",
    "alsoKnownAs": null,
    "text": "buddy tree"
  },
  "build-heap": {
    "definition": "Convert an array into a heap by executing heapify progressively closer to the root.  For an array of n nodes, this takes O(n) time under the comparison model.",
    "alsoKnownAs": null,
    "text": "build-heap"
  },
  "Burrows-Wheeler transform": {
    "definition": "Permute a string. Repeated substrings lead to repeated  characters in the permuted string, which is easier to compress. Knowing which character was last in the original string, the original can be reconstructed from the rearranged string.",
    "alsoKnownAs": "BWT.",
    "text": "Burrows-Wheeler transform"
  },
  "busy beaver": {
    "definition": "(1) A Turing machine with a small number of states that halts when started with a blank tape, but writes a huge number of non-blanks or takes a huge number of steps.  (2) The problem of finding the maximum number of non-blanks written or steps taken for any Turing machines with a given number of states and symbols.",
    "alsoKnownAs": null,
    "text": "busy beaver"
  },
  "BV-tree": {
    "definition": "A conceptual idea which generalizes B-trees to multiple dimensions.  BV-trees are not balanced, and searching may require backtracking.",
    "alsoKnownAs": null,
    "text": "BV-tree"
  },
  "Byzantine generals": {
    "definition": "The problem of reaching a consensus among distributed units if some of them give misleading answers.  To be memorable, the problem is couched in terms of generals deciding on a common plan of attack. Some traitorous generals may lie about whether they will support a particular plan and what other generals told them. Exchanging only messages, what decision making algorithm should the generals use to reach a consensus? What percentage of liars can the algorithm tolerate and still correctly determine a consensus?",
    "alsoKnownAs": null,
    "text": "Byzantine generals"
  },
  "cactus stack": {
    "definition": "A variant of stack in which one other cactus stack may be attached to the top.  An attached stack is called a \"branch.\"  When a branch becomes empty, it is removed.  Pop is not allowed if there is a branch.  A branch is only accessible through the original reference; it is not accessible through the stack.",
    "alsoKnownAs": "saguaro stack.",
    "text": "cactus stack"
  },
  "Calculus of Communicating Systems": {
    "definition": "Robin Milner's algebraic theory to formalize the notion of concurrent computation.  Commonly known as CCS.",
    "alsoKnownAs": null,
    "text": "Calculus of Communicating Systems"
  },
  "calendar queue": {
    "definition": "A fast priority queue implementation having N buckets each with width w, or covering w time.  An item with priority p more than current goes in bucket (p/w)%N.   Choose N and w to have few items in each bucket.  Keep items sorted within buckets.  Double or halve N and change w if the number of items grows or shrinks a lot.",
    "alsoKnownAs": null,
    "text": "calendar queue"
  },
  "candidate consistency testing": {
    "definition": "The stage of two-dimensional matching where a candidate occurrence of the pattern is checked against the \"witness\" table.",
    "alsoKnownAs": null,
    "text": "candidate consistency testing"
  },
  "candidate verification": {
    "definition": "The stage of two-dimensional matching where candidate occurrences of the pattern are actually tested.",
    "alsoKnownAs": null,
    "text": "candidate verification"
  },
  "canonical complexity class": {
    "definition": "One of the classes defined by logarithmic, polynomial, and exponential bounds on time and space, for deterministic and nondeterministic machines.  These classify most of the important computational problems.",
    "alsoKnownAs": null,
    "text": "canonical complexity class"
  },
  "capacitated facility location": {
    "definition": "Given a set of demand points, a distance function, and a parameter p, find a set of p supply object (points, lines, segments, etc.) which minimizes some distance objective function and no supply supports too many demand points.",
    "alsoKnownAs": null,
    "text": "capacitated facility location"
  },
  "capacity": {
    "definition": "The maximum flow that may be sent through an edge or a vertex.",
    "alsoKnownAs": null,
    "text": "capacity"
  },
  "capacity constraint": {
    "definition": "The property that the flow on every edge of a flow network is no more than the edge's capacity.  More formally, for all edges e, f(e) ≤ u(e), where f(e) is the flow on e and u(e) is its capacity.",
    "alsoKnownAs": null,
    "text": "capacity constraint"
  },
  "Caverphone": {
    "definition": "An algorithm to code English names phonetically.",
    "alsoKnownAs": null,
    "text": "Caverphone"
  },
  "CCS": {
    "definition": "Robin Milner's algebraic theory to formalize the notion of concurrent computation.  An acronym for Calculus of Communicating Systems.",
    "alsoKnownAs": null,
    "text": "CCS"
  },
  "cell probe model": {
    "definition": "A model of computation where the cost of a computation is measured by the total number of memory accesses to a random access memory with ⌈log n⌉ bits cell size.  All other computations are not counted and are considered to be free.",
    "alsoKnownAs": null,
    "text": "cell probe model"
  },
  "cell tree": {
    "definition": "A spatial access method where successive levels are split by arbitrary hyperplanes.  Concave objects are decomposed into convex pieces.  Each convex piece is indexed in every cell which it overlaps.",
    "alsoKnownAs": null,
    "text": "cell tree"
  },
  "cellular automaton": {
    "definition": "Usually a two-dimensional organization of simple  finite state machines whose next state depends on their own state and the states of their eight closest neighbors. In general the machines may be arranged in meshes of higher or lower dimension, have larger neighborhoods, or be arbitrarily complex processors.",
    "alsoKnownAs": null,
    "text": "cellular automaton"
  },
  "centroid": {
    "definition": "The center of gravity or center of mass of an object.",
    "alsoKnownAs": null,
    "text": "centroid"
  },
  "certificate": {
    "definition": "(1) Extra information so the correctness of an answer to a decision problem can be quickly checked.  (2) For any graph property  P and graph G, a certificate for G is a graph G' such that G has property  P if and only if G' has the property.",
    "alsoKnownAs": null,
    "text": "certificate"
  },
  "chain": {
    "definition": "A set with a total order.",
    "alsoKnownAs": null,
    "text": "chain"
  },
  "chaining": {
    "definition": "A class of collision resolution schemes in which  linked lists handle collisions in a hash table.  The two main subclasses are separate chaining, where lists are outside the table, and coalesced chaining, where the lists are within the table.",
    "alsoKnownAs": null,
    "text": "chaining"
  },
  "child": {
    "definition": "A node of a tree referred to by a parent node.  See the figure at tree.  Every node, except the root, is the child of some parent.",
    "alsoKnownAs": null,
    "text": "child"
  },
  "Chinese postman problem": {
    "definition": "Find a minimum length closed walk that traverses each edge at least once.  Finding an optimal solution in a graph with both directed and undirected edges is NP-complete.",
    "alsoKnownAs": null,
    "text": "Chinese postman problem"
  },
  "Chinese remainder theorem": {
    "definition": "An integer n can be solved uniquely mod  LCM(A(i)), given modulii (n mod A(i)), A(i) > 0 for i=1..k, k > 0. In other words, given the remainders an integer gets when it's divided by an arbitrary set of divisors, you can uniquely determine the integer's remainder when it is divided by the least common multiple of those divisors.",
    "alsoKnownAs": null,
    "text": "Chinese remainder theorem"
  },
  "Christofides algorithm": {
    "definition": "(1) A heuristic algorithm to find a near-optimal solution to the traveling salesman problem.  Step 1: find a minimum spanning tree T.  Step 2: find a perfect matching M among vertices with odd degree.  Step 3: combine the edges of M and T to make a multigraph G.  Step 4: find an Euler cycle in G. Step 5: Turn the Euler cycle into a Hamiltonian cycle by skipping vertices already seen.  (2) An algorithm to find the chromatic number of a graph.",
    "alsoKnownAs": null,
    "text": "Christofides algorithm"
  },
  "chromatic index": {
    "definition": "The minimum number of colors needed to color the edges of a graph.",
    "alsoKnownAs": null,
    "text": "chromatic index"
  },
  "chromatic number": {
    "definition": "The minimum number of colors needed to color the vertices of a graph such that no two adjacent vertices have the same color.",
    "alsoKnownAs": null,
    "text": "chromatic number"
  },
  "circuit": {
    "definition": "(1) An acyclic network of inputs, logic gates, and outputs.  Contrasted with a Turing machine, it has no memory. (2) A cycle in a graph.",
    "alsoKnownAs": null,
    "text": "circuit"
  },
  "circuit complexity": {
    "definition": "The study of the size, depth, and other attributes of circuits that decide specified languages or compute specified functions.",
    "alsoKnownAs": null,
    "text": "circuit complexity"
  },
  "circuit value problem": {
    "definition": "Given an encoding  α of a boolean circuit α, inputs x1, … , xn and a designated output y, the problem of deciding if output y of α is true on input x1, … , xn.",
    "alsoKnownAs": null,
    "text": "circuit value problem"
  },
  "circular list": {
    "definition": "A variant of a linked list in which the nominal tail is linked to the head.  The entire list may be accessed starting at any item and following links until one comes to the starting item again.",
    "alsoKnownAs": null,
    "text": "circular list"
  },
  "circular queue": {
    "definition": "An implementation of a bounded queue using an array.",
    "alsoKnownAs": null,
    "text": "circular queue"
  },
  "clique": {
    "definition": "A set of vertices in an undirected graph in which there is an edge between every pair of vertices. In other words, a subgraph that is complete.",
    "alsoKnownAs": null,
    "text": "clique"
  },
  "clique problem": {
    "definition": "Find the largest clique in an undirected graph.",
    "alsoKnownAs": null,
    "text": "clique problem"
  },
  "clustering": {
    "definition": "The tendency for entries in a hash table using open addressing to be stored together, even when the table has ample empty space to spread them out.",
    "alsoKnownAs": null,
    "text": "clustering"
  },
  "clustering free": {
    "definition": "When a collision resolution scheme spreads out entries in a hash table.",
    "alsoKnownAs": null,
    "text": "clustering free"
  },
  "coalesced chaining": {
    "definition": "A scheme in which linked lists within the hash table handle collisions.  An item that collides is put in the next empty place in the array and added to the end of a list embedded in the array items.  Any open addressing method to compute possible new positions may be used to find the \"next\" empty place.",
    "alsoKnownAs": null,
    "text": "coalesced chaining"
  },
  "coarsening": {
    "definition": "To alter a problem, typically restricting it to a less complex feasible region or objective function, so that the resulting problem can be efficiently solved, usually by dynamic programming.",
    "alsoKnownAs": null,
    "text": "coarsening"
  },
  "codeword": {
    "definition": "Sequence of bits of a code corresponding to a symbol.",
    "alsoKnownAs": null,
    "text": "codeword"
  },
  "coding tree": {
    "definition": "A full binary tree that represents a coding, such as produced by Huffman coding.  Each leaf is an encoded symbol.  The path from the root to a leaf is its codeword.",
    "alsoKnownAs": null,
    "text": "coding tree"
  },
  "Collatz problem": {
    "definition": "Consider the function: if N is odd, 3 × N + 1; else N/2. Does beginning with any positive integer and repeatedly applying the function always yields 1?",
    "alsoKnownAs": null,
    "text": "Collatz problem"
  },
  "collective recursion": {
    "definition": "A special form of tail recursion, where the results are produced during the recursive calls and nothing is returned.  The recursion may be optimized away by executing the call in the current stack frame, rather than creating a new stack frame, or by deallocating the entire recursion stack at once rather than a little at each return.",
    "alsoKnownAs": null,
    "text": "collective recursion"
  },
  "collision": {
    "definition": "When two or more items should be kept in the same location, especially in hash tables, that is, when two or more different keys hash to the same value.",
    "alsoKnownAs": null,
    "text": "collision"
  },
  "collision resolution scheme": {
    "definition": "A way of handling collisions, that is, when two or more items should be kept in the same location, especially in a hash table. The general ways are keeping subsequent items within the table and computing possible locations (open addressing), keeping lists for items that collide (chaining), or keeping one special overflow area.",
    "alsoKnownAs": null,
    "text": "collision resolution scheme"
  },
  "combination": {
    "definition": "Choose m of n elements, where m ≤ n.",
    "alsoKnownAs": null,
    "text": "combination"
  },
  "comb sort": {
    "definition": "An in-place sort algorithm that repeatedly reorders different pairs of items.  On each pass swap pairs of items separated by the increment or gap, if needed, and reduce the gap (divide it by about 1.3).  The gap starts at about 3/4 of the number of items.  Continue until the gap is 1 and a pass had no swaps.",
    "alsoKnownAs": null,
    "text": "comb sort"
  },
  "Commentz-Walter": {
    "definition": "A multiple string matching algorithm that compares from the end of the pattern, like Boyer-Moore, using a finite state machine, like Aho-Corasick.",
    "alsoKnownAs": null,
    "text": "Commentz-Walter"
  },
  "Communicating Sequential Processes": {
    "definition": "C. A. R. Hoare's algebraic theory to formalize the notion of concurrent computation.  Commonly known as CSP.",
    "alsoKnownAs": null,
    "text": "Communicating Sequential Processes"
  },
  "commutative": {
    "definition": "A function where f(A, B) = f(B, A).",
    "alsoKnownAs": null,
    "text": "commutative"
  },
  "compact data structure": {
    "definition": "A data structure that needs far less space and allows efficient access without decompression.",
    "alsoKnownAs": null,
    "text": "compact data structure"
  },
  "compact DAWG": {
    "definition": "A directed acyclic word graph (DAWG) representing the suffixes of a given string in which each edge is labeled with the longest possible string.  The strings along a path from the root to a node are the substring which the node represents.",
    "alsoKnownAs": null,
    "text": "compact DAWG"
  },
  "compact trie": {
    "definition": "A trie in which nonbranching subtrees leading to leaf nodes are cut off.",
    "alsoKnownAs": null,
    "text": "compact trie"
  },
  "comparison sort": {
    "definition": "Any sort algorithm using comparisons between keys, and nothing else about the keys, to arrange items in a predetermined order.  An alternative is a restricted universe sort such as counting sort or bucket sort.",
    "alsoKnownAs": null,
    "text": "comparison sort"
  },
  "competitive analysis": {
    "definition": "An analysis in which the performance of an on-line algorithm is compared to the best that could have been achieved if all the inputs had been known in advance.",
    "alsoKnownAs": null,
    "text": "competitive analysis"
  },
  "competitive ratio": {
    "definition": "The worst case of the ratio between the cost incurred by an on-line algorithm and the best-case cost.",
    "alsoKnownAs": null,
    "text": "competitive ratio"
  },
  "complement": {
    "definition": "(1) Of a boolean, 0 if 1, or 1 if 0.  See not.  (2) Of a set A, a set having all the members which are in the universe, but not in A.",
    "alsoKnownAs": null,
    "text": "complement"
  },
  "complete binary tree": {
    "definition": "A binary tree in which every level (depth), except possibly the deepest, is completely filled.  At depth n, the height of the tree, all nodes must be as far left as possible.",
    "alsoKnownAs": null,
    "text": "complete binary tree"
  },
  "complete graph": {
    "definition": "An undirected graph with an edge between every pair of vertices.",
    "alsoKnownAs": null,
    "text": "complete graph"
  },
  "complete tree": {
    "definition": "A tree in which every level, except possibly the deepest, is entirely filled.  At depth n, the height of the tree, all nodes are as far left as possible.",
    "alsoKnownAs": null,
    "text": "complete tree"
  },
  "complexity": {
    "definition": "The intrinsic minimum amount of resources, for instance, memory, time, messages, etc., needed to solve a problem or execute an algorithm.",
    "alsoKnownAs": null,
    "text": "complexity"
  },
  "complexity class": {
    "definition": "Any of a set of computational problems with the same bounds (Θ(n)) on time and space, for deterministic and nondeterministic machines.",
    "alsoKnownAs": null,
    "text": "complexity class"
  },
  "compound algorithm": {
    "definition": "An algorithm in which one or more of the computable steps is a call to execute another algorithm.",
    "alsoKnownAs": null,
    "text": "compound algorithm"
  },
  "computable": {
    "definition": "A function that can be computed by an algorithm --- equivalently, by a Turing machine.",
    "alsoKnownAs": null,
    "text": "computable"
  },
  "concurrent data structure": {
    "definition": "A data structure designed to work correctly while being accessed by many asynchronous threads. The two main types are blocking and nonblocking.",
    "alsoKnownAs": null,
    "text": "concurrent data structure"
  },
  "concurrent flow": {
    "definition": "A multi-commodity flow in which the same fraction of the demand of each commodity is satisfied.",
    "alsoKnownAs": null,
    "text": "concurrent flow"
  },
  "concurrent read, concurrent write": {
    "definition": "A parallel memory model in which multiple processors can read simultaneously from a single memory location, and multiple processors can write simultaneously to a single memory location.",
    "alsoKnownAs": "CRCW.",
    "text": "concurrent read, concurrent write"
  },
  "concurrent read, exclusive write": {
    "definition": "A parallel memory model in which multiple processors can read simultaneously from a single memory location, but only one processor can write to any one memory location at one time.",
    "alsoKnownAs": "CREW.",
    "text": "concurrent read, exclusive write"
  },
  "confluently persistent data structure": {
    "definition": "A fully persistent data structure that allows meld or merge operations to combine two different versions.",
    "alsoKnownAs": null,
    "text": "confluently persistent data structure"
  },
  "conjunction": {
    "definition": "The boolean and function.",
    "alsoKnownAs": null,
    "text": "conjunction"
  },
  "connected components": {
    "definition": "The set of maximally connected components of an undirected graph.",
    "alsoKnownAs": null,
    "text": "connected components"
  },
  "connected graph": {
    "definition": "An undirected graph that has a path between every pair of vertices.",
    "alsoKnownAs": null,
    "text": "connected graph"
  },
  "constant function": {
    "definition": "A function that always gives the same value.",
    "alsoKnownAs": null,
    "text": "constant function"
  },
  "Cook reduction": {
    "definition": "A reduction computed by a deterministic polynomial time oracle Turing machine.",
    "alsoKnownAs": null,
    "text": "Cook reduction"
  },
  "Cook's theorem": {
    "definition": "The language SAT of satisfiable Boolean formulas is NP-complete.",
    "alsoKnownAs": null,
    "text": "Cook's theorem"
  },
  "CORDIC": {
    "definition": "Compute trigonometric functions by iterative complex rotations. The advantage is that all computations can be done with addition, subtraction, and binary shifts.",
    "alsoKnownAs": null,
    "text": "CORDIC"
  },
  "counting sort": {
    "definition": "A 2-pass sort algorithm that is efficient when the number of distinct keys is small compared to the number of items.  The first pass counts the occurrences of each key in an auxiliary array, and then makes a running total so each auxiliary entry is the number of preceding keys.  The second pass puts each item in its final place according to the auxiliary entry for that key.",
    "alsoKnownAs": null,
    "text": "counting sort"
  },
  "covering": {
    "definition": "Given a finite collection of subsets of a finite ground set, to find an optimal subcollection whose union covers the ground set.",
    "alsoKnownAs": null,
    "text": "covering"
  },
  "critical path problem": {
    "definition": "Find the longest path from any source to any sinks in a directed acyclic graph which has weights, or numeric values, on vertices.",
    "alsoKnownAs": null,
    "text": "critical path problem"
  },
  "CSP": {
    "definition": "C. A. R. Hoare's algebraic theory to formalize the notion of concurrent computation.  An acronym for Communicating Sequential Processes.",
    "alsoKnownAs": null,
    "text": "CSP"
  },
  "CTL": {
    "definition": "A propositional, branching-time temporal logic for which formulas can be checked in linear time.  An acronym for Computation  Tree Logic.",
    "alsoKnownAs": null,
    "text": "CTL"
  },
  "cube root": {
    "definition": "This describes a \"long hand\" or manual method of calculating or extracting cube roots.  Calculation of a cube root by hand is similar to long-hand division or manual square root.",
    "alsoKnownAs": null,
    "text": "cube root"
  },
  "cuckoo hashing": {
    "definition": "A dictionary implemented with two hash tables, T1 and T2, and two different  hash functions, h1 and h2.  Each key, k, is either in T1[h1(k)] or T2[h2(k)].  A new key, k, is stored in T1[h1(k)].  If that location is already occupied by another key, l, the other key is moved to T2[h2(l)].  Keys are moved back and forth until a key moves to an empty location or a limit is reached. If the limit is reached, new hash functions are chosen, and the tables are rehashed.  For tables that are a bit less than half full and with carefully chosen universal hashing functions, performance is good.  A key is deleted by removing it from a table.",
    "alsoKnownAs": null,
    "text": "cuckoo hashing"
  },
  "Cupif-Giannini tree traversal": {
    "definition": "Visit every leaf of a perfect binary tree with maximum dispersion (see note).  For a tree of height n, use an n-bit \"count\" integer.  The least significant bit of count indicates whether to go to the left or right child from the root. Each more significant bit indicates whether to go left or right.  Regular binary counting generates the list of 2n paths to the leaves.",
    "alsoKnownAs": null,
    "text": "Cupif-Giannini tree traversal"
  },
  "cut": {
    "definition": "A nonempty, proper subset of vertices of a graph.",
    "alsoKnownAs": null,
    "text": "cut"
  },
  "cutting plane": {
    "definition": "A valid inequality for an integer polyhedron that separates the polyhedron from a given point outside it.",
    "alsoKnownAs": null,
    "text": "cutting plane"
  },
  "cutting stock problem": {
    "definition": "Find the best arrangement of shapes on rectangles to minimize waste or the number of rectangles.  This is a two-dimensional variant of the bin packing problem.  It is NP-complete.",
    "alsoKnownAs": null,
    "text": "cutting stock problem"
  },
  "cutting theorem": {
    "definition": "For any set  H of n hyperplanes in ℜk, and any parameter r, 1 ≤ r≤ n, there always exists a (1/r)-cutting of size O(rk).  In two dimensions, a (1/r)-cutting of size s is a partition of the plane into s disjoint triangles, some of which are unbounded, such that no triangle in the partition intersects more than n/r lines in  H.  In ℜk, triangles are replaced by simplices. Such a cutting can be computed in O(nrk-1) time.",
    "alsoKnownAs": null,
    "text": "cutting theorem"
  },
  "cut vertex": {
    "definition": "A vertex whose deletion along with incident edges results in a graph with more components than the original graph.",
    "alsoKnownAs": "articulation point.",
    "text": "cut vertex"
  },
  "cycle": {
    "definition": "A path that starts and ends at the same vertex and includes at least one edge.",
    "alsoKnownAs": null,
    "text": "cycle"
  },
  "cyclic redundancy check": {
    "definition": "(1) A method to detect and correct errors by adding bits derived from a block or string of bits to the block. (2) An algorithm to compute bits characteristic of a block based on the algebra of polynomials over the integers, modulo 2. (3) The characteristic bits of a block.",
    "alsoKnownAs": "CRC.",
    "text": "cyclic redundancy check"
  },
  "D-adjacent": {
    "definition": "An entry reachable for a (d-1)-extremal entry through a unit vertical, horizontal, or diagonal-mismatch step.",
    "alsoKnownAs": null,
    "text": "D-adjacent"
  },
  "DAG shortest paths": {
    "definition": "Solve the single-source shortest-path problem in a weighted directed acyclic graph by 1) doing a topological sort on the vertices by edge so vertices with no incoming edges are first and vertices with only incoming edges are last, 2) assign an infinite distance to every vertex (dist(v)=∞) and a zero distance to the source, and 3) for each vertex v in sorted order, for each outgoing edge e(v,u), if dist(v) + weight(e) < dist(u), set dist(u)=dist(v) + weight(e) and the predecessor of u to v.",
    "alsoKnownAs": null,
    "text": "DAG shortest paths"
  },
  "data structure": {
    "definition": "An organization of information, usually in memory, for better algorithm efficiency, such as queue, stack, linked list, heap, dictionary, and tree, or conceptual unity, such as the name and address of a person.  It may include redundant information, such as length of the list or number of nodes in a subtree.",
    "alsoKnownAs": null,
    "text": "data structure"
  },
  "decidable language": {
    "definition": "A language for which membership can be decided by an algorithm that halts on all inputs in a finite number of steps --- equivalently, can be recognized by a Turing machine that halts for all inputs.",
    "alsoKnownAs": "recursive language, totally decidable language.",
    "text": "decidable language"
  },
  "decidable problem": {
    "definition": "A decision problem that can be solved by an algorithm that halts on all inputs in a finite number of steps.  The associated language is called a decidable language.",
    "alsoKnownAs": "totally decidable problem, algorithmically solvable, recursively solvable.",
    "text": "decidable problem"
  },
  "decision problem": {
    "definition": "A problem with a \"yes\" or \"no\" answer.  Equivalently, a function whose range is two values, such as {0,1}.",
    "alsoKnownAs": null,
    "text": "decision problem"
  },
  "decomposable searching problem": {
    "definition": "A searching problem for which one can decompose the searched domain into subsets, find answers from these subsets, and combine these answers to form the solution to the original problem.  More formally a problem with a query Q is decomposable given if there exists an efficiently computable associative and commutative binary operator @ satisfying the condition: Q(x, A ∪ B) = @(Q(x,A),Q(x,B)).",
    "alsoKnownAs": null,
    "text": "decomposable searching problem"
  },
  "degree": {
    "definition": "(1) Of a vertex, the number of edges connected to it.  (2) Of a graph, the maximum degree of any vertex. (3) Of a tree node, the number of child nodes it has.",
    "alsoKnownAs": null,
    "text": "degree"
  },
  "dense graph": {
    "definition": "A graph in which the number of edges is close to the possible number of edges.",
    "alsoKnownAs": null,
    "text": "dense graph"
  },
  "depoissonization": {
    "definition": "To interpret a solution to a poisson model in the original model after poissonization.",
    "alsoKnownAs": null,
    "text": "depoissonization"
  },
  "depth": {
    "definition": "Of a node, the distance from the node to the root of the tree.",
    "alsoKnownAs": null,
    "text": "depth"
  },
  "depth-first search": {
    "definition": "(1) Any search algorithm that considers outgoing edges (children) of a vertex before any of the vertex's siblings, that is, outgoing  edges of the vertex's predecessor in the search.  Extremes are searched first.  This is easily implemented with recursion.  (2) An algorithm that marks all vertices in a directed graph in the order they are discovered and finished, partitioning the graph into a forest.",
    "alsoKnownAs": "DFS.",
    "text": "depth-first search"
  },
  "deque": {
    "definition": "A data structure in which items may be added to or deleted from the head or the tail.",
    "alsoKnownAs": "doubly-ended queue.",
    "text": "deque"
  },
  "derangement": {
    "definition": "A permutation of elements, where no element is in its original position.",
    "alsoKnownAs": null,
    "text": "derangement"
  },
  "descendant": {
    "definition": "A child of a node in a tree, any of the children of the children, etc.",
    "alsoKnownAs": null,
    "text": "descendant"
  },
  "deterministic": {
    "definition": "Permitting at most one next move at any step in a computation.",
    "alsoKnownAs": null,
    "text": "deterministic"
  },
  "deterministic algorithm": {
    "definition": "An algorithm whose behavior can be completely predicted from the input.",
    "alsoKnownAs": null,
    "text": "deterministic algorithm"
  },
  "deterministic finite automata string search": {
    "definition": "A string matching algorithm which builds a deterministic finite state machine to recognize the search string.  The machine is then run at each location in turn.  If the machine accepts, that is a match.",
    "alsoKnownAs": null,
    "text": "deterministic finite automata string search"
  },
  "deterministic finite state machine": {
    "definition": "A finite state machine with at most one transition for each symbol and state.",
    "alsoKnownAs": "DFA, deterministic finite automaton.",
    "text": "deterministic finite state machine"
  },
  "deterministic finite tree automaton": {
    "definition": "A deterministic finite state machine that accepts finitary trees rather than just strings.  The tree nodes are marked with the letters of the alphabet of the automaton, and the transition function encodes the next states for each branch of the tree.  The acceptance condition is modified accordingly.",
    "alsoKnownAs": "DFTA.",
    "text": "deterministic finite tree automaton"
  },
  "deterministic tree automaton": {
    "definition": "A deterministic finite state machine that accepts infinite trees rather than just strings.  The tree nodes are marked with the letters of the alphabet of the automaton, and the transition function encodes the next states for each branch of the tree.  The expressive power of such automata varies depending on the acceptance conditions of the trees.",
    "alsoKnownAs": null,
    "text": "deterministic tree automaton"
  },
  "Deutsch-Jozsa algorithm": {
    "definition": "A quantum algorithm to determine whether a function is constant or balanced, that is, returns 1 for half the domain and 0 for the other half.  For a function taking n input qubits, first, do Hadamards on n 0's, forming all possible inputs, and a single 1, which will be the answer qubit. Next, run the function once; this exclusive or's the result with the answer qubit.  Finally, do Hadamards on the n inputs again, and measure the answer qubit.  If it is 0, the function is constant, otherwise the function is balanced.",
    "alsoKnownAs": null,
    "text": "Deutsch-Jozsa algorithm"
  },
  "DFS forest": {
    "definition": "A rooted forest formed by depth-first search.",
    "alsoKnownAs": null,
    "text": "DFS forest"
  },
  "diagonalization": {
    "definition": "A proof technique for showing that a given language does not belong to a given complexity class, used in many separation theorems.",
    "alsoKnownAs": null,
    "text": "diagonalization"
  },
  "diameter": {
    "definition": "The maximum of the distances between all possible pairs of vertices of a graph.",
    "alsoKnownAs": null,
    "text": "diameter"
  },
  "Dianna": {
    "definition": "A wonderful wife, too.  A blessing from God since my first wife passed away.",
    "alsoKnownAs": null,
    "text": "Dianna"
  },
  "dichotomic search": {
    "definition": "Search by selecting between two distinct alternatives (dichotomies) at each step.",
    "alsoKnownAs": null,
    "text": "dichotomic search"
  },
  "dictionary": {
    "definition": "An abstract data type storing items, or values.  A value is accessed by an associated key. Basic operations are new, insert, find and delete.",
    "alsoKnownAs": "association list, map, property list.",
    "text": "dictionary"
  },
  "difference": {
    "definition": "The difference of set A minus set B is a set having all the members which are in A, but not in B.",
    "alsoKnownAs": null,
    "text": "difference"
  },
  "digital search tree": {
    "definition": "A trie which stores the strings in internal nodes, so there is no need for extra leaf nodes to store the strings.",
    "alsoKnownAs": null,
    "text": "digital search tree"
  },
  "digital tree": {
    "definition": "A tree for storing strings in which nodes are organized by substrings common to two or more strings.",
    "alsoKnownAs": null,
    "text": "digital tree"
  },
  "Dijkstra's algorithm": {
    "definition": "An algorithm to find the shortest paths from a single source vertex to all other vertices in a weighted, directed graph.  All weights must be nonnegative.",
    "alsoKnownAs": null,
    "text": "Dijkstra's algorithm"
  },
  "diminishing increment sort": {
    "definition": "An in-place sort algorithm that repeatedly reorders different, small subsets of the input until the entire array is ordered. On each pass it handles i sets of n/i items, where n is the total number of items.  Each set is every ith item, e.g. set 1 is item 1, 1+i, 1+2i, etc., set 2 is item 2, 2+i, etc.  On each succeeding pass, the increment or gap, i, is reduced until it is 1 for the last pass.",
    "alsoKnownAs": null,
    "text": "diminishing increment sort"
  },
  "dining philosophers": {
    "definition": "Suppose a number of philosophers surround a dining table.   Adjacent philosophers share one fork.   They spend time thinking or trying to eat.   A philosopher must have both the fork on the left and the fork on the right to eat.  Clearly adjacent philosophers cannot eat at the same time.  The problem is to find an algorithm for taking forks that prevents deadlock, starvation, etc.",
    "alsoKnownAs": null,
    "text": "dining philosophers"
  },
  "direct chaining": {
    "definition": "A collision resolution scheme in which the hash table is an array of links to lists. Each list holds all the items with the same hash value.",
    "alsoKnownAs": null,
    "text": "direct chaining"
  },
  "directed acyclic graph": {
    "definition": "A directed graph with no path that starts and ends at the same vertex.",
    "alsoKnownAs": "DAG, acyclic directed graph, oriented acyclic graph.",
    "text": "directed acyclic graph"
  },
  "directed acyclic word graph": {
    "definition": "(1) A directed acyclic graph representing the suffixes of a given string in which each edge is labeled with a character.  The characters along a path from the root to a node are the substring which the node represents. (2) A finite state machine that recognizes a set of words.",
    "alsoKnownAs": "DAWG.",
    "text": "directed acyclic word graph"
  },
  "directed graph": {
    "definition": "A graph whose edges are ordered pairs of  vertices.  That is, each edge can be followed from one vertex to another vertex.",
    "alsoKnownAs": "digraph, oriented graph.",
    "text": "directed graph"
  },
  "discrete interval encoding tree": {
    "definition": "A binary search tree that stores consecutive values as intervals.",
    "alsoKnownAs": "diet.",
    "text": "discrete interval encoding tree"
  },
  "discrete p-center": {
    "definition": "A facility location problem in which the supply points must be a subset of demand points.",
    "alsoKnownAs": null,
    "text": "discrete p-center"
  },
  "disjoint set": {
    "definition": "A set whose members do not overlap, are not duplicated, etc.",
    "alsoKnownAs": null,
    "text": "disjoint set"
  },
  "disjunction": {
    "definition": "The boolean or function.",
    "alsoKnownAs": null,
    "text": "disjunction"
  },
  "distributional complexity": {
    "definition": "The expected running time of the best possible deterministic algorithm over the worst possible probability distribution on the inputs.",
    "alsoKnownAs": null,
    "text": "distributional complexity"
  },
  "distribution sort": {
    "definition": "Any sort algorithm where items are distributed from the input to multiple intermediate structures, which are then gathered and placed on the output.",
    "alsoKnownAs": null,
    "text": "distribution sort"
  },
  "distributive partitioning sort": {
    "definition": "Step 1: find the median key. Step 2: distribute the n items into n/2 buckets linearly covering the interval from the minimum to the median and n/2 buckets linearly covering the interval from the median to the maximum.   Step 3: compact the buckets, removing empty buckets.  Recursively start again at step 1 for any bucket with multiple items.  Linked lists are used to avoid moving items until a final phase and to avoid bucket overflows.",
    "alsoKnownAs": null,
    "text": "distributive partitioning sort"
  },
  "divide and conquer": {
    "definition": "Solve a problem, either directly because solving that instance is easy (typically, because the instance is small) or by dividing it into two or more smaller instances.  Each of these smaller instances is  recursively solved, and the solutions are combined to produce a solution for the original instance.",
    "alsoKnownAs": null,
    "text": "divide and conquer"
  },
  "divide and marriage before conquest": {
    "definition": "A variant of divide and conquer in which subproblems created in the \"divide\" step are merged before the \"conquer\" step.",
    "alsoKnownAs": null,
    "text": "divide and marriage before conquest"
  },
  "domain": {
    "definition": "(1) The inputs for which a function or relation is defined. For instance, 0 is not in the domain of reciprocal (1/x).  (2) The possible values of a variable.",
    "alsoKnownAs": null,
    "text": "domain"
  },
  "don't care": {
    "definition": "A special symbol which matches any other symbol of a given alphabet.",
    "alsoKnownAs": null,
    "text": "don't care"
  },
  "Doomsday rule": {
    "definition": "An algorithm to find the day of the week for any date.  It is simple enough to memorize and do mentally.",
    "alsoKnownAs": null,
    "text": "Doomsday rule"
  },
  "double-ended priority queue": {
    "definition": "A priority queue which simultaneously keeps track of the maximum and minimum keys, and supports operations efficiently on either extreme (minimum or maximum).",
    "alsoKnownAs": null,
    "text": "double-ended priority queue"
  },
  "double hashing": {
    "definition": "A method of open addressing for a hash table in which a collision is resolved by searching the table for an empty place at intervals given by a different hash function, thus minimizing clustering.",
    "alsoKnownAs": "rehashing.",
    "text": "double hashing"
  },
  "double metaphone": {
    "definition": "An algorithm to code English words (and foreign words often heard in the United States) phonetically by reducing them to a combination of 12 consonant sounds.   It returns two codes if a word has two plausible pronunciations, such as a foreign word. This reduces matching problems from wrong spelling.",
    "alsoKnownAs": null,
    "text": "double metaphone"
  },
  "doubly linked list": {
    "definition": "A variant of a linked list in which each item has a link to the previous item as well as the next.  This allows easily accessing list items backward as well as forward and deleting any item in constant time.",
    "alsoKnownAs": "two-way linked list, symmetrically linked list.",
    "text": "doubly linked list"
  },
  "D-tree": {
    "definition": "(1) A BB(α) tree where the weights are the number of searches down that path.   (2) A height-balanced binary tree that divides regions along their boundaries to serve as a  spatial access method.",
    "alsoKnownAs": null,
    "text": "D-tree"
  },
  "dual": {
    "definition": "The dual of a planar graph, G, is a graph with a vertex for each region in G and an edge between vertices for each pair of adjacent regions.  The new edge crosses the edge in G which is the boundary between the adjacent regions.",
    "alsoKnownAs": null,
    "text": "dual"
  },
  "dual linear program": {
    "definition": "Every linear program has a corresponding linear program called the dual.  It is maxy{b· y | ATy ≤ c  and y ≥  0}.  For any solution x to the original linear program and any solution y to the dual we have c · x ≥ (AT y)T x = yT(Ax) ≥ y · b.  For optimal x and y, equality holds.  For a problem formulated as an integer linear program, a solution to the dual of a relaxation of the program can serve as witness.",
    "alsoKnownAs": null,
    "text": "dual linear program"
  },
  "dual-pivot quicksort": {
    "definition": "Pick two elements from the array to be sorted (the pivots), partition the remaining elements into (i) those less than the lesser pivot, (ii) those between the pivots, and (iii) those greater than the greater pivot, and recursively sort these partitions.",
    "alsoKnownAs": null,
    "text": "dual-pivot quicksort"
  },
  "Dutch national flag": {
    "definition": "Rearrange elements in an array into three groups: bottom, middle, and top.",
    "alsoKnownAs": null,
    "text": "Dutch national flag"
  },
  "dynamic": {
    "definition": "When the problem domain may change, e.g., there may be insertions and deletions.",
    "alsoKnownAs": null,
    "text": "dynamic"
  },
  "dynamic array": {
    "definition": "An array whose size may change over time.  Items are not only added or removed, but memory used changes, too.",
    "alsoKnownAs": null,
    "text": "dynamic array"
  },
  "dynamic hashing": {
    "definition": "A hash table that grows to handle more items.  The associated hash function must change as the table grows.  Some schemes may shrink the table to save space when items are deleted.",
    "alsoKnownAs": null,
    "text": "dynamic hashing"
  },
  "dynamic programming": {
    "definition": "Solve an optimization problem by caching subproblem solutions (memoization) rather than recomputing them.",
    "alsoKnownAs": null,
    "text": "dynamic programming"
  },
  "dynamization transformation": {
    "definition": "A data structuring technique that can make a static data structure dynamic.  In so doing, the performance of the dynamic structure will exhibit certain space-time tradeoffs.",
    "alsoKnownAs": null,
    "text": "dynamization transformation"
  },
  "easy split, hard merge": {
    "definition": "A recursive algorithm, especially a sort algorithm, where dividing (splitting) into smaller problems is quick or simple and combining (merging) the solutions is time consuming or complex.",
    "alsoKnownAs": null,
    "text": "easy split, hard merge"
  },
  "edge": {
    "definition": "A connection between two vertices of a graph.  In a weighted graph, each edge has an number, called a \"weight\".  In a directed graph, an edge goes from one vertex, the source, to another, the target, and hence makes connection in only one direction.",
    "alsoKnownAs": "arc.",
    "text": "edge"
  },
  "edge coloring": {
    "definition": "An assignment of colors (or any distinct marks) to the  edges of a graph.  A coloring is a proper coloring if no two adjacent edges have the same color.",
    "alsoKnownAs": null,
    "text": "edge coloring"
  },
  "edge connectivity": {
    "definition": "(1) The smallest number of edges whose deletion will cause a connected graph to not be connected.  (2) For a pair of vertices s and t in a graph, the smallest number of edges whose deletion will separate s from t.",
    "alsoKnownAs": null,
    "text": "edge connectivity"
  },
  "edge crossing": {
    "definition": "Two different edges cross in a graph drawing if their geometric representations intersect.  The number of crossings in a graph drawing is the number of pairs of edges which cross.",
    "alsoKnownAs": null,
    "text": "edge crossing"
  },
  "edit operation": {
    "definition": "On a string, the operation of deletion, insertion, or substitution performed on a single symbol.  On a tree, the deletion of a node v followed by the reassignment of all children of v to the node of which v was formerly a child, the insertion of a new node followed by the reassignment of some arcs departing from the parent of the new node, or the substitution of the label of one of the nodes with another label.  Each edit operation may have an associated nonnegative real number representing its cost.",
    "alsoKnownAs": null,
    "text": "edit operation"
  },
  "edit script": {
    "definition": "A sequence of viable edit operations on a string or tree.",
    "alsoKnownAs": null,
    "text": "edit script"
  },
  "efficiency": {
    "definition": "The resources an algorithm used to find an answer.  It is usually measured in terms of the theoretical computations, such as comparisons or data moves, the memory used, the number of messages passed, the number of disk accesses, etc.",
    "alsoKnownAs": null,
    "text": "efficiency"
  },
  "8 queens": {
    "definition": "Place eight chess queens on an 8 × 8 board such that no queen can attack another.  Efficiently find all possible placements.",
    "alsoKnownAs": null,
    "text": "8 queens"
  },
  "elastic-bucket trie": {
    "definition": "A variant of a bucket trie in which each leaf node for n strings is a bucket allocated to hold exactly n strings.",
    "alsoKnownAs": null,
    "text": "elastic-bucket trie"
  },
  "element uniqueness": {
    "definition": "The problem of determining if there are duplicates in a set of numbers.",
    "alsoKnownAs": null,
    "text": "element uniqueness"
  },
  "end-of-string": {
    "definition": "A special character indicating the end of a string.",
    "alsoKnownAs": null,
    "text": "end-of-string"
  },
  "Euclidean distance": {
    "definition": "The straight line distance between two points.  In a plane with p1 at (x1, y1) and p2 at (x2, y2), it is  √((x1 - x2)² + (y1 - y2)²).",
    "alsoKnownAs": null,
    "text": "Euclidean distance"
  },
  "Euclidean Steiner tree": {
    "definition": "A tree of minimum Euclidean distance connecting a set of points, called terminals, in the plane.  This tree may include points other than the terminals, which are called Steiner points.",
    "alsoKnownAs": null,
    "text": "Euclidean Steiner tree"
  },
  "Euclidean traveling salesman problem": {
    "definition": "Find a path of minimum Euclidean distance between points in a plane which includes each point exactly once and returns to its starting point.",
    "alsoKnownAs": null,
    "text": "Euclidean traveling salesman problem"
  },
  "Euclid's algorithm": {
    "definition": "An algorithm to compute the greatest common divisor of two positive integers.  It is Euclid(a,b){if (b=0) then return a; else return Euclid(b, a mod b);}.  The run time complexity is  O((log a)(log b)) bit operations.",
    "alsoKnownAs": "Euclidean algorithm.",
    "text": "Euclid's algorithm"
  },
  "Euler cycle": {
    "definition": "A path through a graph which starts and ends at the same vertex and includes every edge exactly once.",
    "alsoKnownAs": "Eulerian path, Königsberg bridges problem.",
    "text": "Euler cycle"
  },
  "Eulerian graph": {
    "definition": "A graph that has an Euler cycle.",
    "alsoKnownAs": null,
    "text": "Eulerian graph"
  },
  "Euler's formula": {
    "definition": "For convex polyhedron, V - E + F = 2, where V is the number of vertices, E is the number of edges, and F is the number of faces.",
    "alsoKnownAs": null,
    "text": "Euler's formula"
  },
  "EXCELL": {
    "definition": "A point access method using a dynamic multidimensional array.",
    "alsoKnownAs": null,
    "text": "EXCELL"
  },
  "exclusive read, concurrent write": {
    "definition": "A parallel memory model in which only one processor can read from any one memory location at one time, but multiple processors can write simultaneously to a single memory location.",
    "alsoKnownAs": "ERCW.",
    "text": "exclusive read, concurrent write"
  },
  "exclusive read, exclusive write": {
    "definition": "A parallel memory model in which only one processor can read from any one memory location at one time, and only one processor can write to any one memory location at one time.",
    "alsoKnownAs": "EREW.",
    "text": "exclusive read, exclusive write"
  },
  "exhaustive search": {
    "definition": "An algorithm that finds a solution by trying every possibility.",
    "alsoKnownAs": null,
    "text": "exhaustive search"
  },
  "existential state": {
    "definition": "A state in a nondeterministic Turing machine from which the machine accepts if any move leads to acceptance.",
    "alsoKnownAs": null,
    "text": "existential state"
  },
  "exponential": {
    "definition": "(1) Any function which is the sum of constants times other constants to the power of the argument: f(x)=Σi=0k cibixpi. (2) In complexity theory, the measure of computation, m(n) (usually execution time or memory space), is bounded by an exponential function of the problem size, n.  More formally if there exists k > 1 such that m(n) = Θ(kn) and there exists c such that m(n) = O(cn).",
    "alsoKnownAs": null,
    "text": "exponential"
  },
  "extended binary tree": {
    "definition": "A binary tree with special nodes replacing every null subtree.  Every regular node has two children, and every special node has no children.",
    "alsoKnownAs": null,
    "text": "extended binary tree"
  },
  "extended Euclid's algorithm": {
    "definition": "An algorithm to find the greatest common divisor, g, of two positive integers, a and b, and coefficients, h and j, such that g = ha + jb.",
    "alsoKnownAs": null,
    "text": "extended Euclid's algorithm"
  },
  "extended k-d tree": {
    "definition": "A spatial access method where successive levels are split along different dimensions into nonoverlapping cells.  Objects are indexed in all cells they intersect.",
    "alsoKnownAs": null,
    "text": "extended k-d tree"
  },
  "extendible hashing": {
    "definition": "A hash table in which the hash function is the last few bits of the key and the table refers to buckets.  Table entries with the same final bits may use the same bucket.  If a bucket overflows, it splits, and if only one entry referred to it, the table doubles in size.  If a bucket is emptied by deletion, entries using it are changed to refer to an adjoining bucket, and the table may be halved.",
    "alsoKnownAs": null,
    "text": "extendible hashing"
  },
  "external index": {
    "definition": "An auxiliary data structure added to a main data structure to improve operations, such as a search on a secondary key.",
    "alsoKnownAs": null,
    "text": "external index"
  },
  "external memory algorithm": {
    "definition": "An algorithm that is efficient when accessing most of the data is very slow, such as, on disk.",
    "alsoKnownAs": null,
    "text": "external memory algorithm"
  },
  "external memory data structure": {
    "definition": "A data structure that is efficient even when accessing most of the data is very slow, such as, on a disk.",
    "alsoKnownAs": null,
    "text": "external memory data structure"
  },
  "external merge": {
    "definition": "To combine multiple sorted data streams into a single sorted stream using external storage.",
    "alsoKnownAs": null,
    "text": "external merge"
  },
  "external quicksort": {
    "definition": "Read the M/2 first and last elements into a buffer (the buffer acts like the pivot in quicksort), and sort them.  Read the next element from the beginning or end to balance writing.  If the next element is less than the least of the buffer, write it to available space at the beginning.  If greater than the greatest, write it to the end.  Otherwise write the greatest or least of the buffer, and put the next element in the buffer.  Keep the maximum lower and minimum upper keys written to avoid resorting middle elements that are in order.   When done, write the buffer.  Recursively sort the smaller partition, and loop to sort the remaining partition.",
    "alsoKnownAs": null,
    "text": "external quicksort"
  },
  "external sort": {
    "definition": "Any sort algorithm that uses external memory, such as tape or disk, during the sort.  Since most common sort algorithms assume high-speed random access to all intermediate memory, they are unsuitable if the values to be sorted don't fit in main memory.",
    "alsoKnownAs": null,
    "text": "external sort"
  },
  "extremal": {
    "definition": "Some of the entries of the auxiliary array used in a string matching algorithm.  An entry is d-extremal if it is the deepest entry on its diagonal to be given value d.",
    "alsoKnownAs": null,
    "text": "extremal"
  },
  "extreme point": {
    "definition": "A corner point of a polyhedron.  More formally, a point which cannot be expressed as a convex combination of other points in the polyhedron.",
    "alsoKnownAs": null,
    "text": "extreme point"
  },
  "facility location": {
    "definition": "Given a set of demand points, a distance function, and a parameter p, find a set of p supply objects (points, lines, segments, etc.) which minimizes some distance objective function. The function may be the maximum distance between any demand point and the nearest supply, so no demand point is too far from a supply, or the sum of distances to the nearest supply.",
    "alsoKnownAs": null,
    "text": "facility location"
  },
  "factorial": {
    "definition": "The factorial of an integer n ≥ 0, written n!, is n × n-1 × … × 2 × 1.  In particular, 0! = 1.",
    "alsoKnownAs": null,
    "text": "factorial"
  },
  "fast fourier transform": {
    "definition": "An algorithm to convert a set of uniformly spaced points from the time domain to the frequency domain.",
    "alsoKnownAs": "FFT.",
    "text": "fast fourier transform"
  },
  "fathoming": {
    "definition": "Pruning a search tree.",
    "alsoKnownAs": null,
    "text": "fathoming"
  },
  "feasible region": {
    "definition": "The set of all possible solutions of an optimization problem.",
    "alsoKnownAs": null,
    "text": "feasible region"
  },
  "feasible solution": {
    "definition": "Any element of the feasible region of an optimization problem.",
    "alsoKnownAs": null,
    "text": "feasible solution"
  },
  "feedback edge set": {
    "definition": "The smallest set of edges whose deletion results in an acyclic graph.",
    "alsoKnownAs": null,
    "text": "feedback edge set"
  },
  "feedback vertex set": {
    "definition": "The smallest set of vertices whose deletion results in an acyclic graph.",
    "alsoKnownAs": null,
    "text": "feedback vertex set"
  },
  "Fibonaccian search": {
    "definition": "Search a sorted array by narrowing possible locations to progressively smaller intervals.  Begin with two Fibonacci numbers, p (F(n)) and q (F(n+1)), such that p < n ≤ q, where n is the size of the array.  The first step checks location p.  The size of the next interval is p, if the key is less than the item at that location, or q-p (F(n-1)) if it is greater.",
    "alsoKnownAs": null,
    "text": "Fibonaccian search"
  },
  "Fibonacci heap": {
    "definition": "A heap made of a forest of trees.  The amortized cost of the operations create, insert a value, decrease a value, find minimum, and merge or join (meld) two heaps, is a constant Θ(1).  The delete operation takes O(log n).",
    "alsoKnownAs": null,
    "text": "Fibonacci heap"
  },
  "Fibonacci number": {
    "definition": "A member of the sequence of numbers such that each number is  the sum of the preceding two.   The first seven numbers are 1, 1, 2, 3, 5, 8, and 13. F(n) ≈ round(Φn/√ 5), where Φ=(1+√ 5)/2.",
    "alsoKnownAs": null,
    "text": "Fibonacci number"
  },
  "Fibonacci tree": {
    "definition": "A variant of a binary tree where a tree of order n (n>1) has a left subtree of order n-1 and a right subtree of order n-2.  An order 0 Fibonacci tree has no nodes, and an order 1 tree has 1 node.",
    "alsoKnownAs": null,
    "text": "Fibonacci tree"
  },
  "Find": {
    "definition": "An algorithm to select the kth smallest element of an array and partition the array around it.  First, partition around the value of the kth element.  If the split is not at element k, move the upper or lower boundary and partition again.",
    "alsoKnownAs": null,
    "text": "Find"
  },
  "finitary tree": {
    "definition": "A tree with a finite number of children at every node.",
    "alsoKnownAs": null,
    "text": "finitary tree"
  },
  "finite state machine": {
    "definition": "A model of computation consisting of a set of states, a start state, an input alphabet, and a transition function that maps input symbols and current states to a next state. Computation begins in the start state with an input string.  It changes to new states depending on the transition function. There are many variants, for instance, machines having actions (outputs) associated with transitions (Mealy machine) or states (Moore machine), multiple start states, transitions conditioned on no input symbol (a null) or more than one transition for a given symbol and state (nondeterministic finite state machine), one or more states designated as accepting states (recognizer), etc.",
    "alsoKnownAs": "finite state automaton.",
    "text": "finite state machine"
  },
  "finite state transducer": {
    "definition": "A finite state machine specifically with a read-only input and a write-only output.  The input and output cannot be reread or changed.",
    "alsoKnownAs": null,
    "text": "finite state transducer"
  },
  "first-in, first-out": {
    "definition": "A policy that items are processed in order of arrival.  A queue implements this.",
    "alsoKnownAs": null,
    "text": "first-in, first-out"
  },
  "Fisher-Yates shuffle": {
    "definition": "Randomly permute N elements by exchanging each element ei with a random element from i to N. It consumes Θ(N log N) bits and runs in linear time.",
    "alsoKnownAs": null,
    "text": "Fisher-Yates shuffle"
  },
  "fixed-grid method": {
    "definition": "Space decomposition into rectangular cells by overlaying a grid on it.If the cells are congruent (i.e.,of the same width, height, etc.), then the grid is said to be uniform.",
    "alsoKnownAs": null,
    "text": "fixed-grid method"
  },
  "flow": {
    "definition": "A measure of the maximum weight along paths in a  weighted, directed graph.",
    "alsoKnownAs": null,
    "text": "flow"
  },
  "flow conservation": {
    "definition": "The property that no vertex, except the source and sink, of a flow network creates or stores flow.  More formally, the incoming flow is the same as the outgoing flow, or, the net flow is 0.",
    "alsoKnownAs": null,
    "text": "flow conservation"
  },
  "flow function": {
    "definition": "An assignment of flow values to the edges of a flow network that satisfies flow conservation, skew symmetry, and capacity constraints.",
    "alsoKnownAs": "network flow.",
    "text": "flow function"
  },
  "flow network": {
    "definition": "A weighted, directed graph with two specially marked nodes, the source s and the sink t, and a capacity function that maps edges to positive real numbers, u: E |→ ℜ+.",
    "alsoKnownAs": null,
    "text": "flow network"
  },
  "Floyd-Warshall algorithm": {
    "definition": "An algorithm to solve the all pairs shortest path problem in a weighted, directed graph by multiplying an adjacency-matrix representation of the graph multiple times.  The edges may have negative weights, but no negative weight cycles. The time complexity is Θ (V³).",
    "alsoKnownAs": null,
    "text": "Floyd-Warshall algorithm"
  },
  "Ford-Fulkerson method": {
    "definition": "Given a flow function and its corresponding residual graph (a maximum-flow problem), select a path from the source to the sink along which the flow can be increased and increase the flow. Repeat until there are no such paths.",
    "alsoKnownAs": null,
    "text": "Ford-Fulkerson method"
  },
  "forest": {
    "definition": "A collection of one or more trees.",
    "alsoKnownAs": null,
    "text": "forest"
  },
  "forest editing problem": {
    "definition": "The problem of finding an edit script of minimum cost which transforms a given forest into another given forest.",
    "alsoKnownAs": null,
    "text": "forest editing problem"
  },
  "formal methods": {
    "definition": "A group of analytical approaches having mathematically precise foundation which can serve as a framework or adjunct for human engineering and design skills and experience.",
    "alsoKnownAs": null,
    "text": "formal methods"
  },
  "formal verification": {
    "definition": "Establishing properties of hardware or software designs using logic, rather than (just) testing or informal arguments.  This involves formal specification of the requirement, formal modeling of the implementation, and precise rules of inference to prove, say, that the implementation satisfies the specification.",
    "alsoKnownAs": null,
    "text": "formal verification"
  },
  "forward index": {
    "definition": "An index into a set of texts.  This is usually created as the first step to making an inverted index.",
    "alsoKnownAs": null,
    "text": "forward index"
  },
  "fractional knapsack problem": {
    "definition": "Given materials of different values per unit volume and maximum amounts, find the most valuable mix of materials which fit in a knapsack of fixed volume.  Since we may take pieces (fractions) of materials, a greedy algorithm finds the optimum.  Take as much as possible of the material that is most valuable per unit volume.  If there is still room, take as much as possible of the next most valuable material.  Continue until the knapsack is full.",
    "alsoKnownAs": "continuous knapsack problem.",
    "text": "fractional knapsack problem"
  },
  "fractional solution": {
    "definition": "Typically, a solution to a relaxation of an optimization problem.",
    "alsoKnownAs": null,
    "text": "fractional solution"
  },
  "free edge": {
    "definition": "An edge which is not in a matching.",
    "alsoKnownAs": null,
    "text": "free edge"
  },
  "free tree": {
    "definition": "A connected, acyclic, undirected graph.",
    "alsoKnownAs": null,
    "text": "free tree"
  },
  "free vertex": {
    "definition": "A vertex not on a matched edge in a matching, or, one which has not been matched.",
    "alsoKnownAs": null,
    "text": "free vertex"
  },
  "frequency count heuristic": {
    "definition": "A heuristic that keeps the elements of a list ordered by number of times each element is the target of a search.",
    "alsoKnownAs": null,
    "text": "frequency count heuristic"
  },
  "full array": {
    "definition": "A term from combinatorial chemistry referring to trying all possible combinations of blocks.  This is not a data structure, and is here to reduce confusion.",
    "alsoKnownAs": null,
    "text": "full array"
  },
  "full binary tree": {
    "definition": "A binary tree in which each node has exactly zero or two children.",
    "alsoKnownAs": "proper binary tree.",
    "text": "full binary tree"
  },
  "full inverted index": {
    "definition": "An inverted index that includes the exact location within texts, in addition to the text in which the word appears.",
    "alsoKnownAs": null,
    "text": "full inverted index"
  },
  "fully dynamic graph problem": {
    "definition": "Problem where the update operations include unrestricted insertions and deletions of edges.",
    "alsoKnownAs": null,
    "text": "fully dynamic graph problem"
  },
  "fully persistent data structure": {
    "definition": "A persistent data structure that allows updates to all versions, previous and latest.",
    "alsoKnownAs": null,
    "text": "fully persistent data structure"
  },
  "fully polynomial approximation scheme": {
    "definition": "A set of algorithms {Aε | ε > 0},  where each Aε is a 1+ε-approximation algorithm bounded by a polynomial in the length of the input and 1/ε.",
    "alsoKnownAs": null,
    "text": "fully polynomial approximation scheme"
  },
  "function": {
    "definition": "(1) A computation which takes some arguments or inputs and yields an output.  Any particular input yields the same output every time.  More formally, a mapping from each element in the domain to an element in the range.  (2) A subroutine which returns a value.",
    "alsoKnownAs": null,
    "text": "function"
  },
  "gamma function": {
    "definition": "The gamma function of n, written Γ(n), is  ∫ 0∞ e-xxn-1dx.  Recursively Γ(n+1) = nΓ(n).  For non-negative integers Γ(n+1) = n!.",
    "alsoKnownAs": null,
    "text": "gamma function"
  },
  "GBD-tree": {
    "definition": "A generalized BD-tree, hence the name, which stores spatially extended objects as a hierarchy  of minimum bounding boxes.  It is a balanced multiway tree which serves as a spatial access method.",
    "alsoKnownAs": null,
    "text": "GBD-tree"
  },
  "geometric optimization problem": {
    "definition": "An optimization problem induced by a collection of geometric objects.",
    "alsoKnownAs": null,
    "text": "geometric optimization problem"
  },
  "global optimum": {
    "definition": "The best possible solution to a problem.",
    "alsoKnownAs": null,
    "text": "global optimum"
  },
  "gnome sort": {
    "definition": "Put items in order by comparing the current item with the previous item.  If they are in order, move to the next item (or stop if the end is reached).  If they are out of order, swap them and move to the previous item.  If there is no previous item, move to the next item.",
    "alsoKnownAs": null,
    "text": "gnome sort"
  },
  "graph": {
    "definition": "A set of items connected by edges.  Each item is called a vertex or node.  Formally, a graph is a set of vertices and a binary relation between vertices, adjacency.",
    "alsoKnownAs": null,
    "text": "graph"
  },
  "graph concentration": {
    "definition": "Contracting a graph by removing a subset of the vertices.",
    "alsoKnownAs": null,
    "text": "graph concentration"
  },
  "graph drawing": {
    "definition": "The problem of representing a graph in a plane \"neatly,\" for instance with a minimum number of edge crossings.",
    "alsoKnownAs": null,
    "text": "graph drawing"
  },
  "graph isomorphism": {
    "definition": "Determine if two graphs are isomorphic.",
    "alsoKnownAs": null,
    "text": "graph isomorphism"
  },
  "graph partition": {
    "definition": "Partition the vertices while keeping the cost of spanning edges low.",
    "alsoKnownAs": null,
    "text": "graph partition"
  },
  "Gray code": {
    "definition": "An ordering of 2n binary numbers such that only one bit changes from one entry to the next.  Gray codes for 4 or more bits are not unique, even allowing for permutation or inversion of bits.",
    "alsoKnownAs": null,
    "text": "Gray code"
  },
  "greatest common divisor": {
    "definition": "(1) The greatest integer which is a divisor of given positive integers.  For instance, GCD(30, 42) = 6.  (2) An algorithm to find the same.",
    "alsoKnownAs": "GCD, highest common factor.",
    "text": "greatest common divisor"
  },
  "greedy algorithm": {
    "definition": "An algorithm that always takes the best immediate, or local, solution while finding an answer.  Greedy algorithms find the overall, or globally, optimal solution for some optimization problems, but may find less-than-optimal solutions for some instances of other problems.",
    "alsoKnownAs": null,
    "text": "greedy algorithm"
  },
  "greedy heuristic": {
    "definition": "Solve an optimization problem by finding locally optimal solutions.",
    "alsoKnownAs": null,
    "text": "greedy heuristic"
  },
  "grid drawing": {
    "definition": "A graph drawing in which each vertex is represented by a point with integer coordinates.",
    "alsoKnownAs": null,
    "text": "grid drawing"
  },
  "grid file": {
    "definition": "A point access method which splits space into a nonperiodic grid.  Each spatial dimension is divided by a linear hash.  Small sets of points are referred to by one or more cells of the grid.",
    "alsoKnownAs": null,
    "text": "grid file"
  },
  "halting problem": {
    "definition": "Is there an algorithm to determine whether any arbitrary program halts?  Turing proved the answer is, no. Since many questions can be recast to this problem, we can conclude that some programs are absolutely impossible, although heuristic or partial solutions are possible.",
    "alsoKnownAs": null,
    "text": "halting problem"
  },
  "Hamiltonian cycle": {
    "definition": "A path through a graph that starts and ends at the same vertex and includes every other vertex exactly once.",
    "alsoKnownAs": "tour.",
    "text": "Hamiltonian cycle"
  },
  "Hamiltonian path": {
    "definition": "A simple path through a graph that includes every vertex in the graph.",
    "alsoKnownAs": null,
    "text": "Hamiltonian path"
  },
  "Hamming distance": {
    "definition": "The number of bits which differ between two binary strings. More formally, the distance between two strings A and B is ∑ | Ai - Bi |.",
    "alsoKnownAs": null,
    "text": "Hamming distance"
  },
  "hard split, easy merge": {
    "definition": "A recursive algorithm, especially a sort algorithm, where dividing (splitting) into smaller problems is time consuming or complex and combining (merging) the solutions is quick or trivial.",
    "alsoKnownAs": null,
    "text": "hard split, easy merge"
  },
  "hashbelt": {
    "definition": "Use a short list or array of hash tables to implement a hash table with aging to expire items.  To expire items, add a new table at the head of the list and drop the oldest table, along with its contents.  To find an item, search all the tables.",
    "alsoKnownAs": null,
    "text": "hashbelt"
  },
  "hash function": {
    "definition": "A function that maps keys to integers, usually to get an even distribution on a smaller set of values.",
    "alsoKnownAs": "hash.",
    "text": "hash function"
  },
  "hash heap": {
    "definition": "An efficient implementation of a priority queue.  The  linear hash function monotonically maps keys to buckets, and each bucket is a heap.",
    "alsoKnownAs": null,
    "text": "hash heap"
  },
  "hash table": {
    "definition": "A dictionary in which keys are mapped to  array positions by hash functions.  Having the keys of more than one item map to the same position is called a collision. There are many collision resolution schemes, but they may be divided into open addressing, chaining, and keeping one special overflow area. Perfect hashing avoids collisions, but may be time-consuming to create.",
    "alsoKnownAs": "scatter storage.",
    "text": "hash table"
  },
  "hash table delete": {
    "definition": "If the hash table uses chaining, use the chaining data structure delete.  If it uses open addressing, mark the item \"deleted\" for future reuse.",
    "alsoKnownAs": null,
    "text": "hash table delete"
  },
  "Hausdorff distance": {
    "definition": "A measure of the resemblance of two (fixed) sets of geometric points P and Q, defined as H(P,Q)=max{maxa∈ P minb∈ Q d(a,b), maxa∈ Q minb∈ P d(a,b)} where d(·,·) is the distance metric, usually the Euclidean distance.",
    "alsoKnownAs": null,
    "text": "Hausdorff distance"
  },
  "hB-tree": {
    "definition": "A point access method which uses k-d trees to organize the space, but partitions as excluded intervals, like the BANG file.  Searching is like in a k-d-B-tree.",
    "alsoKnownAs": null,
    "text": "hB-tree"
  },
  "head": {
    "definition": "The first item of a list.",
    "alsoKnownAs": null,
    "text": "head"
  },
  "heap": {
    "definition": "A complete tree where every node has a key more extreme (greater or less) than or equal to the key of its parent. Usually understood to be a binary heap.",
    "alsoKnownAs": null,
    "text": "heap"
  },
  "heapify": {
    "definition": "Rearrange a heap to maintain the heap property, that is, the key of the root node is more extreme (greater or less) than or equal to the keys of its children.  If the root node's key is not more extreme, swap it with the most extreme child key, then recursively heapify that child's subtree.  The child subtrees must be heaps to start.",
    "alsoKnownAs": null,
    "text": "heapify"
  },
  "heap property": {
    "definition": "Each node in a tree has a key which is more extreme (greater or less) than or equal to the key of its  parent.",
    "alsoKnownAs": null,
    "text": "heap property"
  },
  "heapsort": {
    "definition": "A sort algorithm that builds a heap, then repeatedly extracts the maximum item.  Run time is  O(n log n).",
    "alsoKnownAs": null,
    "text": "heapsort"
  },
  "height": {
    "definition": "The maximum distance of any node from the root. If a tree has only one node (the root), the height is zero.   The height of an empty tree is not defined.",
    "alsoKnownAs": null,
    "text": "height"
  },
  "height-balanced binary search tree": {
    "definition": "A height-balanced tree which is also a binary search tree. It supports membership, insert, and delete operations in time logarithmic in the number of nodes in the tree.",
    "alsoKnownAs": null,
    "text": "height-balanced binary search tree"
  },
  "height-balanced tree": {
    "definition": "A tree whose subtrees differ in height by no more than one and the subtrees are height-balanced, too.  An empty tree is height-balanced.",
    "alsoKnownAs": null,
    "text": "height-balanced tree"
  },
  "heuristic": {
    "definition": "An algorithm that usually, but not always, works or that gives nearly the right answer.",
    "alsoKnownAs": null,
    "text": "heuristic"
  },
  "hidden Markov model": {
    "definition": "A variant of a finite state machine having a set of states, Q, an output alphabet, O, transition probabilities, A, output probabilities, B, and initial state probabilities, Π.  The current state is not observable.  Instead, each state produces an output with a certain probability (B).  Usually the states, Q, and outputs, O, are understood, so an HMM is said to be a triple,  (A, B, Π).",
    "alsoKnownAs": "HMM.",
    "text": "hidden Markov model"
  },
  "histogram sort": {
    "definition": "An efficient 3-pass refinement of a bucket sort algorithm.   The first pass counts the number of items for each bucket in an auxiliary array, and then makes a running total so each auxiliary entry is the number of preceding items.  The second pass puts each item in its proper bucket according to the auxiliary entry for the key of that item.  The last pass sorts each bucket.",
    "alsoKnownAs": "interpolation sort.",
    "text": "histogram sort"
  },
  "homeomorphic": {
    "definition": "Two graphs are homeomorphic if they can be made isomorphic by inserting new vertices of degree 2 into edges.",
    "alsoKnownAs": null,
    "text": "homeomorphic"
  },
  "horizontal visibility map": {
    "definition": "A partition of the plane into regions by drawing a horizontal straight line through each vertex p of a planar straight-line graph until it intersects an edge e of the graph or extends to infinity.  The edge e is said to be horizontally visible from p.",
    "alsoKnownAs": null,
    "text": "horizontal visibility map"
  },
  "Horner's rule": {
    "definition": "A polynomial A(x) = a0 + a1x + a2x² + a3x³ + … may be written as A(x) = a0 + x(a1 + x(a2 + x(a3 + …))).",
    "alsoKnownAs": null,
    "text": "Horner's rule"
  },
  "hsadelta": {
    "definition": "An algorithm to produce a sequence of insert and copy commands (an edit script) which creates a new version file from a reference file. To begin, hash every block of the reference file and store every hash in a hash value array.  Build a suffix array and three other data  structures for quick access.  Beginning at the first location in the version file, hash a block and look for the longest match in the reference file.  Upon a match, encode an insert back to the previous match and a copy of the match.  If no match, look at the next location.  At the end, encode an insert for remaining unmatched characters.",
    "alsoKnownAs": null,
    "text": "hsadelta"
  },
  "Huffman coding": {
    "definition": "A minimal variable-length character coding based on the frequency of  each character.  First, each character becomes a one-node binary tree, with the character as the only node.  The character's frequency is the tree's frequency.  Two trees with the least frequencies are joined as the subtrees of a new root that is assigned the sum of their frequencies. Repeat until all characters are in one tree.  One code bit represents each level.  Thus more frequent characters are near the root and are coded with few bits, and rare characters are far from the root and are coded with many bits.",
    "alsoKnownAs": "static Huffman coding.",
    "text": "Huffman coding"
  },
  "huge sparse array": {
    "definition": "Let N be the number of items to store and R be the size of the range of key values; R >> N.   Allocate, but don't initialize, two arrays: an item array I, where |I|≥N, and a location array L, where |L|=R. Initialize a variable, next, the number of items, to zero (with 0-based indexing). To insert an item, put it in the next place in the item array and save where to find it in the location array.",
    "alsoKnownAs": null,
    "text": "huge sparse array"
  },
  "hybrid algorithm": {
    "definition": "Any algorithm composed of simpler algorithms.",
    "alsoKnownAs": null,
    "text": "hybrid algorithm"
  },
  "hyperedge": {
    "definition": "A connection between any number of vertices of a  hypergraph.",
    "alsoKnownAs": null,
    "text": "hyperedge"
  },
  "hypergraph": {
    "definition": "A graph whose hyperedges connect two or more  vertices.",
    "alsoKnownAs": null,
    "text": "hypergraph"
  },
  "HyperLogLog": {
    "definition": "Estimate the number of unique items by setting m = 2b counters to maximum value (e.g. all 1 bits). Hash each item to get an L bit result. The first b bits of the result indicate a counter.  Set that counter to the minimum of the remaining L-b bits and the counter value. When finished with all items, compute the harmonic mean of the number of leading zeros in each counter's value, Z.  The estimate of the number of distinct items is α m² Z.",
    "alsoKnownAs": null,
    "text": "HyperLogLog"
  },
  "ideal merge": {
    "definition": "Merge n sorted streams into one output stream. To begin the streams are sorted by the value of the head element of each. Then the head of the first stream, which is the least since the streams were sorted, is removed and written to the output.  That stream is inserted back into the list of streams according to its new head.  Taking the head of the first stream and reinserting that stream is repeated until all elements have been processed. Using linear search to insert a stream into the list, the execution time is Θ(M N) where M is the total number of elements. Keeping the streams in a heap, the execution time is Θ(M log N).",
    "alsoKnownAs": null,
    "text": "ideal merge"
  },
  "ideal random shuffle": {
    "definition": "A permutation algorithm, or shuffle, that has exactly the same chance of producing any permutation.",
    "alsoKnownAs": null,
    "text": "ideal random shuffle"
  },
  "implication": {
    "definition": "The boolean implies function.",
    "alsoKnownAs": null,
    "text": "implication"
  },
  "implies": {
    "definition": "Implication: 0 → 0 = 1, 0 → 1 = 1,  1 → 0 = 0, 1 → 1 = 1.",
    "alsoKnownAs": null,
    "text": "implies"
  },
  "inclusion-exclusion principle": {
    "definition": "A rule that allows to compute the probability of exactly r occurrences of events A1, A2, … , An.",
    "alsoKnownAs": null,
    "text": "inclusion-exclusion principle"
  },
  "incompressible string": {
    "definition": "A string whose Kolmogorov complexity equals its length, so that it has no shorter encodings.",
    "alsoKnownAs": null,
    "text": "incompressible string"
  },
  "in-degree": {
    "definition": "The number of edges coming into a vertex in a directed graph.",
    "alsoKnownAs": null,
    "text": "in-degree"
  },
  "independent set": {
    "definition": "A set of vertices in a graph such that for any pair of vertices, there is no edge between them.",
    "alsoKnownAs": null,
    "text": "independent set"
  },
  "index file": {
    "definition": "A file which stores keys and an index into another file.  The index file may have additional structure, e.g., be a B-tree.",
    "alsoKnownAs": null,
    "text": "index file"
  },
  "information theoretic bound": {
    "definition": "lower bounds on the execution of a computation based on the rate at which information can be accumulated.",
    "alsoKnownAs": null,
    "text": "information theoretic bound"
  },
  "in-order traversal": {
    "definition": "Process all nodes of a tree by recursively processing the left subtree, then processing the root, and finally the right subtree.",
    "alsoKnownAs": "symmetric traversal.",
    "text": "in-order traversal"
  },
  "in-place sort": {
    "definition": "A sort algorithm in which the sorted items occupy the same storage as the original ones.  These algorithms may use  o(n) additional memory for bookkeeping, but at most a constant number of items are kept in auxiliary memory at any time.",
    "alsoKnownAs": "sort in place.",
    "text": "in-place sort"
  },
  "insertion sort": {
    "definition": "Sort by repeatedly taking the next item and inserting it into the final data structure in its proper order with respect to items already inserted.  Run time is O(n2) because of moves.",
    "alsoKnownAs": "linear insertion sort.",
    "text": "insertion sort"
  },
  "integer linear program": {
    "definition": "A linear program with additional constraints that all of the variables must take on integer values.  Solving such problems is NP-hard.",
    "alsoKnownAs": null,
    "text": "integer linear program"
  },
  "integer multi-commodity flow": {
    "definition": "A multi-commodity flow in which the flow of each commodity through each edge must take an integer value. The term is also used to capture the multi-commodity flow problem in which each demand is routed along a single path.",
    "alsoKnownAs": null,
    "text": "integer multi-commodity flow"
  },
  "integer polyhedron": {
    "definition": "A polyhedron, all of whose extreme points are integer valued.",
    "alsoKnownAs": null,
    "text": "integer polyhedron"
  },
  "interactive proof system": {
    "definition": "A protocol in which one or more provers try to convince another party, called the verifier, that the prover(s) possess certain true knowledge, such as the membership of a string x in a given language, often with the goal of revealing no further details about this knowledge.  The prover(s) and verifier are formally defined as probabilistic Turing machines with special \"interaction tapes\" for exchanging messages.",
    "alsoKnownAs": null,
    "text": "interactive proof system"
  },
  "interior-based representation": {
    "definition": "A representation of a region that is based on its interior (i.e., the cells that compose it).",
    "alsoKnownAs": null,
    "text": "interior-based representation"
  },
  "internal node": {
    "definition": "A node of a tree that has one or more child nodes, equivalently, one that is not a leaf.",
    "alsoKnownAs": "nonterminal node.",
    "text": "internal node"
  },
  "internal sort": {
    "definition": "Any sort algorithm which uses exclusively main memory during the sort.  This assumes high-speed random access to all memory.",
    "alsoKnownAs": null,
    "text": "internal sort"
  },
  "interpolation search": {
    "definition": "Search a sorted array by estimating the next position to check based on a linear interpolation of the search key and the values at the ends of the search interval.",
    "alsoKnownAs": "extrapolation search.",
    "text": "interpolation search"
  },
  "interpolation-sequential search": {
    "definition": "An approximate location is interpolated from the first and last items of a sorted array, then a linear search finds the actual location.",
    "alsoKnownAs": null,
    "text": "interpolation-sequential search"
  },
  "intersection": {
    "definition": "The intersection of two sets is a set having those members which are in both sets.",
    "alsoKnownAs": null,
    "text": "intersection"
  },
  "intractable": {
    "definition": "A problem for which no algorithm can exist which computes all instances of it in polynomial time.",
    "alsoKnownAs": null,
    "text": "intractable"
  },
  "introspective sort": {
    "definition": "A variant of quicksort which switches to heapsort for pathological inputs, that is, when execution time is becoming quadratic.",
    "alsoKnownAs": "introsort.",
    "text": "introspective sort"
  },
  "inverse Ackermann function": {
    "definition": "A function of two parameters whose value grows very, very slowly.",
    "alsoKnownAs": "α.",
    "text": "inverse Ackermann function"
  },
  "inverse suffix array": {
    "definition": "For each position in a string, the inverse suffix array has its index in the string's suffix array.",
    "alsoKnownAs": null,
    "text": "inverse suffix array"
  },
  "inversion list": {
    "definition": "A set of non-overlapping numeric ranges, stored in an array in increasing order.  Items in odd indexes begin ranges, and items in even indexes are the first number after the ends.",
    "alsoKnownAs": null,
    "text": "inversion list"
  },
  "inverted file index": {
    "definition": "An inverted index that only indicates the text in which a word appears, not where the word appears within the text.",
    "alsoKnownAs": null,
    "text": "inverted file index"
  },
  "inverted index": {
    "definition": "An index into a set of texts of the words in the texts. The index is accessed by some search method. Each index entry gives the  word and a list of texts, possibly with locations  within the text, where the word occurs.",
    "alsoKnownAs": null,
    "text": "inverted index"
  },
  "invertible Bloom lookup table": {
    "definition": "Algorithms and an array of cells to store key/value pairs. Each cell has a count of how many pairs are mapped to the cell, the sum of the keys mapped to it, and the sum of the values mapped to it.  Using k hash functions, each pair is mapped to T[h1(k)], T[h2(k)], ..., T[hk(k)].",
    "alsoKnownAs": "IBLT.",
    "text": "invertible Bloom lookup table"
  },
  "irreflexive": {
    "definition": "A binary relation R for which there is no element a such that a R a.",
    "alsoKnownAs": null,
    "text": "irreflexive"
  },
  "isomorphic": {
    "definition": "Two graphs are isomorphic if there  is a one-to-one correspondence between their vertices and there is an edge between two vertices of one graph if and only if there is an edge between the two corresponding vertices in the other graph.",
    "alsoKnownAs": null,
    "text": "isomorphic"
  },
  "iteration": {
    "definition": "Solve a problem by repeatedly working on successive parts of the problem.",
    "alsoKnownAs": null,
    "text": "iteration"
  },
  "Jaro-Winkler": {
    "definition": "A measure of similarity between two strings.  The Jaro measure is the weighted sum of percentage of matched characters from each file and transposed characters.  Winkler increased this measure for matching initial characters, then rescaled it by a piecewise function, whose intervals and weights depend on the type of string (first name, last name, street, etc.).",
    "alsoKnownAs": null,
    "text": "Jaro-Winkler"
  },
  "jelly-fish": {
    "definition": "A theoretical data structure for n items. It starts with a  balanced binary search tree of about  √(n) nodes.   The leaf nodes lead to \"tentacles\" or linked lists, each of about  √(n) nodes.",
    "alsoKnownAs": null,
    "text": "jelly-fish"
  },
  "Johnson's algorithm": {
    "definition": "An algorithm to solve the all pairs shortest path problem in a sparse weighted, directed graph.  First, it adds a new node with zero weight edges from it to all other nodes, and runs the Bellman-Ford algorithm to check for negative weight cycles and find h(v), the least weight of a path from the new node to node v.  Next it reweights the edges using the nodes' h(v) values.  Finally for each node, it runs Dijkstra's algorithm and stores the computed least weight to other nodes, reweighted using the nodes' h(v) values, as the final weight. The time complexity is O(V²log V + VE).",
    "alsoKnownAs": null,
    "text": "Johnson's algorithm"
  },
  "Johnson-Trotter": {
    "definition": "Generate permutations by swapping one adjacent pair of elements at a time.",
    "alsoKnownAs": "Steinhaus-Johnson-Trotter, Trotter-Johnson.",
    "text": "Johnson-Trotter"
  },
  "JSort": {
    "definition": "An in-place sort that partially orders the array twice with build-heap, once moving lesser items earlier and once in reverse moving greater items later, then uses insertion sort on the nearly-ordered array.",
    "alsoKnownAs": null,
    "text": "JSort"
  },
  "J sort": {
    "definition": "An in-place sort algorithm that uses strand sort to sort fewer than about 40 items and shuffle sort to sort more.",
    "alsoKnownAs": null,
    "text": "J sort"
  },
  "jump list": {
    "definition": "A variant of doubly linked list with items in sorted order and having two levels of additional links that span geometrically increasing distances.  For a  list with n items, the next level is a link from item i,  1 ≤ i ≤ n - ⌊ n 1/3⌋, to  item i + ⌊ i 1/3⌋.  At the top level, items 1³, 2³, 3³, …,  ⌊ n 1/3⌋ ³ have backward links, that is, there is a link from item i³,  1 < i ≤ ⌊ n 1/3⌋ ³, to  item (i-1)³.   Search, insert, and delete are O(n1/3) worst case.",
    "alsoKnownAs": null,
    "text": "jump list"
  },
  "jump search": {
    "definition": "Search a sorted array by checking every jth item until the right area is found, then doing a linear search.  The optimum for n items is when j=√ n.",
    "alsoKnownAs": "block search.",
    "text": "jump search"
  },
  "Karnaugh map": {
    "definition": "A method for minimizing a boolean expression, usually aided by a rectangular map of the value of the expression for all possible input values.  Input values are arranged in a Gray code.  Maximal rectangular groups that cover the inputs where the expression is true give a minimum implementation.",
    "alsoKnownAs": "Veitch diagram, KV diagram.",
    "text": "Karnaugh map"
  },
  "Karp-Rabin": {
    "definition": "A string matching algorithm that compares string's  hash values, rather than the strings themselves.  For efficiency, the hash value of the next position in the text is easily computed from the hash value of the current position.",
    "alsoKnownAs": "Rabin-Karp.",
    "text": "Karp-Rabin"
  },
  "Karp reduction": {
    "definition": "A reduction given by a polynomial time computable transformation function.",
    "alsoKnownAs": null,
    "text": "Karp reduction"
  },
  "k-ary heap": {
    "definition": "A complete tree where every node has a key more extreme (greater or less) than the key of its parent.  Each node has k or fewer children.",
    "alsoKnownAs": null,
    "text": "k-ary heap"
  },
  "k-ary Huffman coding": {
    "definition": "A minimal variable-length coding based on the frequency of each character.  Similar to a Huffman coding, but joins k trees into a k-ary tree at each step, and uses k symbols for each level.",
    "alsoKnownAs": null,
    "text": "k-ary Huffman coding"
  },
  "k-ary tree": {
    "definition": "A tree with no more than k children for each node.",
    "alsoKnownAs": "k-way tree.",
    "text": "k-ary tree"
  },
  "k-coloring": {
    "definition": "1) The assignment of k colors (or any distinct marks) to the vertices of a graph. 2) The assignment of k colors to the edges of a graph.",
    "alsoKnownAs": null,
    "text": "k-coloring"
  },
  "k-connected graph": {
    "definition": "A connected graph such that deleting any k-1 vertices (and incident edges) results in a graph that is still connected.",
    "alsoKnownAs": null,
    "text": "k-connected graph"
  },
  "k-d-B-tree": {
    "definition": "A data structure which splits multidimensional spaces like an adaptive k-d tree, but balances the resulting tree like a B-tree.",
    "alsoKnownAs": null,
    "text": "k-d-B-tree"
  },
  "k-dimensional": {
    "definition": "(1) Dealing with or restricted to a space where location can be completely described with exactly k orthogonal axes.  (2) Dealing with a space of any number of dimensions.",
    "alsoKnownAs": null,
    "text": "k-dimensional"
  },
  "K-dominant match": {
    "definition": "A match [i,j] having rank k and such that for any other pair [i',j'] of rank k either i'>i and j'≤ j or i' ≤ i and j'>j.",
    "alsoKnownAs": null,
    "text": "K-dominant match"
  },
  "k-d tree": {
    "definition": "A multidimensional search tree for points in k dimensional space.  Levels of the tree are split along successive dimensions at the points.",
    "alsoKnownAs": null,
    "text": "k-d tree"
  },
  "key": {
    "definition": "The part of a group of data by which it is sorted, indexed, cross referenced, etc.",
    "alsoKnownAs": null,
    "text": "key"
  },
  "knapsack problem": {
    "definition": "Given items of different values and volumes, find the most valuable set of items that fit in a knapsack of fixed volume.",
    "alsoKnownAs": "0-1 knapsack problem, binary knapsack problem.",
    "text": "knapsack problem"
  },
  "knight's tour": {
    "definition": "A series of moves of a chess knight that visits all squares on the board exactly once.",
    "alsoKnownAs": null,
    "text": "knight's tour"
  },
  "Knuth-Morris-Pratt algorithm": {
    "definition": "A string matching algorithm that turns the search string into a finite state machine, then runs the machine with the string to be searched as the input string.  Execution time is O(m+n), where m is the length of the search string, and n is the length of the string to be searched.",
    "alsoKnownAs": "KMP.",
    "text": "Knuth-Morris-Pratt algorithm"
  },
  "Kolmogorov complexity": {
    "definition": "The minimum number of bits into which a string can be compressed without losing information.  This is defined with respect to a fixed, but universal decompression scheme, given by a universal Turing machine.",
    "alsoKnownAs": null,
    "text": "Kolmogorov complexity"
  },
  "Kraft's inequality": {
    "definition": "∑i=1N 2-c(i) ≤ 1, where N is the number of leaves in a binary tree and c(i) is the depth of leaf i.",
    "alsoKnownAs": null,
    "text": "Kraft's inequality"
  },
  "Kripke structure": {
    "definition": "A nondeterministic finite state machine whose states are labeled with boolean variables, which are the evaluations of expressions in that state. It may be extended with fairness constraints.",
    "alsoKnownAs": null,
    "text": "Kripke structure"
  },
  "Kruskal's algorithm": {
    "definition": "An algorithm for computing a minimum spanning tree.  It maintains a set of partial minimum spanning trees, and repeatedly adds the shortest edge in the graph whose vertices are in different partial minimum spanning trees.",
    "alsoKnownAs": null,
    "text": "Kruskal's algorithm"
  },
  "kth order Fibonacci numbers": {
    "definition": "A sequence of numbers where each number is the sum of the k preceding numbers. The usual Fibonacci numbers occur when k=2.",
    "alsoKnownAs": "pth order Fibonacci numbers.",
    "text": "kth order Fibonacci numbers"
  },
  "kth shortest path": {
    "definition": "The problem of finding the kth shortest path from one vertex in a graph to another vertex.  Variants may require that paths are edge- or vertex-disjoint, that is sharing no edges  or vertices.  \"Shortest\" may be least number of edges, least total  weight, etc.",
    "alsoKnownAs": null,
    "text": "kth shortest path"
  },
  "k²-tree": {
    "definition": "A compact representation of a sparse directed graph.  It requires 1 to 3 bits per edge.  Many access functions, like successor(s), predecessor(s), and range (all links from a range of vertices to another range of vertices), have very efficient implementations.",
    "alsoKnownAs": null,
    "text": "k²-tree"
  },
  "k-way merge": {
    "definition": "Combine k sorted data streams into a single sorted stream.",
    "alsoKnownAs": null,
    "text": "k-way merge"
  },
  "k-way merge sort": {
    "definition": "A merge sort that sorts a data stream using repeated merges.  It distributes the input into k streams by repeatedly reading a block of input that fits in memory, called a run, sorting it, then writing it to the next stream.  It merges runs from the k streams into an output stream.  It then repeatedly distributes the runs in the output stream to the k streams and merges them until there is a single sorted output.",
    "alsoKnownAs": "p-way merge sort.",
    "text": "k-way merge sort"
  },
  "labeled graph": {
    "definition": "A graph which has labels associated with each edge or each vertex.",
    "alsoKnownAs": null,
    "text": "labeled graph"
  },
  "language": {
    "definition": "A set of strings over some fixed alphabet.  A characterization of inputs which may or may not be solved by algorithms.",
    "alsoKnownAs": "formal language.",
    "text": "language"
  },
  "last-in, first-out": {
    "definition": "A policy that the most recently arrived item is processed first. A stack implements this.",
    "alsoKnownAs": null,
    "text": "last-in, first-out"
  },
  "Las Vegas algorithm": {
    "definition": "A randomized algorithm that always produces correct results, with the only variation from one run to another being its running time.",
    "alsoKnownAs": null,
    "text": "Las Vegas algorithm"
  },
  "lattice": {
    "definition": "A point lattice generated by taking integer linear combinations of a set of basis vectors.",
    "alsoKnownAs": null,
    "text": "lattice"
  },
  "layered graph": {
    "definition": "A connected graph where \"layers\" L0 … Lk partition the vertices.  Each edge, which has a nonnegative integral weight, connects only vertices in successive layers.  The width is the greatest number of vertices in any layer, i.e.,  MAXi=0k |Li|.",
    "alsoKnownAs": null,
    "text": "layered graph"
  },
  "LCFS hashing": {
    "definition": "In case of collision, move the existing item to another position, dictated by the open addressing scheme used.",
    "alsoKnownAs": null,
    "text": "LCFS hashing"
  },
  "LCS": {
    "definition": "Either longest common subsequence or longest common substring.",
    "alsoKnownAs": null,
    "text": "LCS"
  },
  "leaf": {
    "definition": "A node in a tree without any children. See the figure at tree.",
    "alsoKnownAs": "external node, terminal node.",
    "text": "leaf"
  },
  "least common multiple": {
    "definition": "The least integer which is a multiple of given integers.  For instance, LCM(6, 10) = 30.",
    "alsoKnownAs": "LCM.",
    "text": "least common multiple"
  },
  "leftist tree": {
    "definition": "A priority queue implemented with a variant of a binary tree.  Every node has a count which is the distance to the nearest leaf.  In addition to the heap property, leftist trees are kept so the right descendant of each node has the shorter distance to a leaf.",
    "alsoKnownAs": null,
    "text": "leftist tree"
  },
  "left rotation": {
    "definition": "(1) In a binary search tree, pushing a node N down and to the left to balance the tree.  N's right child replaces N, and the right child's left child becomes N's right child. (2) In an array, moving all items to the next lower location.  The first item is moved to the last location, which is now vacant. (3) In a list, removing the head and inserting it at the tail.",
    "alsoKnownAs": "rotate left.",
    "text": "left rotation"
  },
  "Lempel-Ziv-Welch": {
    "definition": "A compression algorithm that codes strings of characters with codes of a fixed number of bits.  Every new string in the input is added to a table until it is full.  The codes of existing strings are output instead of the strings.",
    "alsoKnownAs": "LZW compression.",
    "text": "Lempel-Ziv-Welch"
  },
  "level": {
    "definition": "(1) All the nodes of a tree with the same depth. (2) Of a node, the depth.",
    "alsoKnownAs": null,
    "text": "level"
  },
  "level-order traversal": {
    "definition": "Process all nodes of a tree by depth: first the root, then the children of the root, etc.  Equivalent to a breadth-first search from the root.",
    "alsoKnownAs": null,
    "text": "level-order traversal"
  },
  "Levenshtein distance": {
    "definition": "(1) The smallest number of insertions, deletions, and substitutions required to change one string or tree into another.  (2) A Θ(m × n) algorithm to compute the distance between strings, where m and n are the lengths of the strings.",
    "alsoKnownAs": "edit distance.",
    "text": "Levenshtein distance"
  },
  "lexicographical order": {
    "definition": "Alphabetical or \"dictionary\" order.",
    "alsoKnownAs": null,
    "text": "lexicographical order"
  },
  "linear": {
    "definition": "(1) Any function which is a constant times the argument plus a constant: f(x)=c1x + c0. (2) In complexity theory, the measure of computation, m(n) (usually execution time or memory space), is bounded by a linear function of the problem size, n.  More formally m(n) = O(n).",
    "alsoKnownAs": null,
    "text": "linear"
  },
  "linear congruential generator": {
    "definition": "A class of algorithms that are pseudo-random number generators.  The next number is generated from the current one by  rn+1 = (A × rn + B) mod  M, where A and M are relatively prime numbers.",
    "alsoKnownAs": null,
    "text": "linear congruential generator"
  },
  "linear hash": {
    "definition": "A numeric function that maintains the order of input keys while changing their spacing.",
    "alsoKnownAs": "order-preserving hash.",
    "text": "linear hash"
  },
  "linear hashing": {
    "definition": "A dynamic hashing table that grows one slot at a time.  It has a family of hash functions, hi, where the range of hi+1 is twice the range of hi.  Slots below a pointer, p, have been split.  That is, key, k, is in slot hi(k) if hi(k) > p.  Otherwise it is in hi+1(k).  To maintain the load factor, slot p can be split (rehashed with hi+1) and p incremented. When p reaches the end, the ranges are doubled (i is incremented), and p starts over.",
    "alsoKnownAs": "incremental hashing.",
    "text": "linear hashing"
  },
  "linear probing": {
    "definition": "A hash table in which a collision is resolved by putting the item in the next empty place in the array following the occupied place.  Even with a moderate load factor, primary clustering tends to slow retrieval.",
    "alsoKnownAs": null,
    "text": "linear probing"
  },
  "linear probing sort": {
    "definition": "Distribute each of n elements to one of m locations in an array (m>n) based on an interpolation of the element's key.  In case of collisions, put the element in the next empty location.  The array has extra space at the end for overflow.  The second pass packs the elements back into an array of size n.",
    "alsoKnownAs": null,
    "text": "linear probing sort"
  },
  "linear product": {
    "definition": "For two vectors X and Y, and with respect to two suitable operations ⊗ and ⊕ is a vector Z=Z0 Z1 … Zm+n where Zk=⊕i+j=kXi ⊗ Yj (k=0, … , m+n).",
    "alsoKnownAs": null,
    "text": "linear product"
  },
  "linear program": {
    "definition": "A problem expressible in the following form.   Given an n × m real matrix A, m-vector b and n-vector c, determine minx{c· x | Ax ≥ b  and x ≥  0} where x ranges over all n-vectors and the inequalities are interpreted component-wise, i.e., x ≥  0 means that the entries of x are nonnegative.",
    "alsoKnownAs": null,
    "text": "linear program"
  },
  "linear quadtree": {
    "definition": "A quadtree implemented as a single array of nodes.",
    "alsoKnownAs": null,
    "text": "linear quadtree"
  },
  "linear search": {
    "definition": "Search an array or list by checking items one at a time.",
    "alsoKnownAs": "sequential search.",
    "text": "linear search"
  },
  "link": {
    "definition": "A reference, pointer, or access handle to another part of the data structure.  Often, a memory address.",
    "alsoKnownAs": null,
    "text": "link"
  },
  "linked data signature": {
    "definition": "A digital signature, and information to verify it, for linked data.",
    "alsoKnownAs": "LDS.",
    "text": "linked data signature"
  },
  "linked list": {
    "definition": "A list implemented by each item having a link to the next item.",
    "alsoKnownAs": "singly linked list.",
    "text": "linked list"
  },
  "list": {
    "definition": "A collection of items accessible one after another beginning at the head and ending at the tail.",
    "alsoKnownAs": null,
    "text": "list"
  },
  "list contraction": {
    "definition": "Contracting a list by removing some of the items.",
    "alsoKnownAs": null,
    "text": "list contraction"
  },
  "little-o notation": {
    "definition": "A theoretical measure of the execution of an algorithm, usually the time or memory needed, given the problem size n, which is usually the number of items.  Informally, saying some equation f(n) = o(g(n)) means f(n) becomes insignificant relative to g(n) as n approaches infinity.   The notation is read, \"f of n is little oh of g of n\".",
    "alsoKnownAs": null,
    "text": "little-o notation"
  },
  "Lm distance": {
    "definition": "The generalized distance between two points.  In a plane with point p1 at (x1, y1) and p2 at (x2, y2), it is  (|x1 - x2|m +   |y1 - y2|m)1/m.",
    "alsoKnownAs": "Minkowski distance.",
    "text": "Lm distance"
  },
  "load factor": {
    "definition": "The number of elements in a hash table divided by the number of slots.  Usually written α (alpha).",
    "alsoKnownAs": null,
    "text": "load factor"
  },
  "local alignment": {
    "definition": "The detection of local similarities among two or more strings.",
    "alsoKnownAs": null,
    "text": "local alignment"
  },
  "locality-sensitive hashing": {
    "definition": "A probabilistic algorithm to quickly find points in a high dimensional space near a query point.  Preprocessing: put every point in multiple hash tables.  Each table has its own locality-sensitive hash function and uses buckets (or chaining) since many collisions are expected. The hash functions come from a family of functions.   Finding: look up the query point in each hash table, and compute the distance from the query point of every point in the bucket.",
    "alsoKnownAs": null,
    "text": "locality-sensitive hashing"
  },
  "local optimum": {
    "definition": "A solution to a problem that is better than all other solutions that are slightly different, but worse than the global optimum.",
    "alsoKnownAs": null,
    "text": "local optimum"
  },
  "logarithmic": {
    "definition": "(1) Any function that is a constant times the logarithm of the argument: f(x)=c log x. (2) In complexity theory, when the measure of computation, m(n) (usually execution time or memory space), is bounded by a logarithmic function of the problem size, n.  More formally m(n) = O(log n). (3) Sometimes imprecisely used to mean polylogarithmic.",
    "alsoKnownAs": null,
    "text": "logarithmic"
  },
  "longest common subsequence": {
    "definition": "The problem of finding a maximum length (or maximum weight) subsequence of two or more strings.",
    "alsoKnownAs": "heaviest common subsequence.",
    "text": "longest common subsequence"
  },
  "longest common substring": {
    "definition": "Find the longest substring of two or more strings.",
    "alsoKnownAs": null,
    "text": "longest common substring"
  },
  "Lotka's law": {
    "definition": "The number of authors making n contributions is about 1/na of those making one contribution, where a is often nearly 2.",
    "alsoKnownAs": null,
    "text": "Lotka's law"
  },
  "lower bound": {
    "definition": "A function or growth rate below which solving a problem is impossible.",
    "alsoKnownAs": null,
    "text": "lower bound"
  },
  "lower triangular matrix": {
    "definition": "A matrix that is only defined at (i,j) when i ≥ j.",
    "alsoKnownAs": null,
    "text": "lower triangular matrix"
  },
  "lowest common ancestor": {
    "definition": "The deepest node in a tree that is an ancestor of two given leaves.",
    "alsoKnownAs": null,
    "text": "lowest common ancestor"
  },
  "l-reduction": {
    "definition": "A Karp reduction that preserves approximation properties of optimization problems.",
    "alsoKnownAs": null,
    "text": "l-reduction"
  },
  "lucky sort": {
    "definition": "The best possible sort algorithm: it is so lucky that the input is already sorted, and it need do nothing!",
    "alsoKnownAs": null,
    "text": "lucky sort"
  },
  "Malhotra-Kumar-Maheshwari blocking flow": {
    "definition": "Given a flow function and its corresponding residual graph (a maximum-flow problem), select a vertex with the least throughput and greedily push the maximum flow from it to the sink.  This is repeated until all vertices are deleted.",
    "alsoKnownAs": null,
    "text": "Malhotra-Kumar-Maheshwari blocking flow"
  },
  "Manhattan distance": {
    "definition": "The distance between two points measured along axes at right angles. In a plane with p1 at (x1, y1) and p2 at (x2, y2), it is  |x1 - x2| + |y1 - y2|.",
    "alsoKnownAs": "rectilinear distance, Minkowski's L1 distance, taxi cab metric, or city block distance.",
    "text": "Manhattan distance"
  },
  "many-one reduction": {
    "definition": "A reduction that maps an instance of one problem into an equivalent instance of another problem.",
    "alsoKnownAs": null,
    "text": "many-one reduction"
  },
  "Markov chain": {
    "definition": "A finite state machine with probabilities for each transition, that is, a probability that the next state is sj given that the current state is si.",
    "alsoKnownAs": null,
    "text": "Markov chain"
  },
  "Marlena": {
    "definition": "A wonderful wife.  Every man should have such an incredible wife.  We were married in 1976, too, and life had only gotten much better until she passed away.",
    "alsoKnownAs": null,
    "text": "Marlena"
  },
  "Master theorem": {
    "definition": "A theorem giving a solution in asymptotic terms for recurrence relations of the form T(n) = aT(n/b) + f(n) where a ≥ 1 and b > 1 are constants and n/b means either ⌊ n/b⌋ or ⌈ n/b⌉.",
    "alsoKnownAs": null,
    "text": "Master theorem"
  },
  "matched edge": {
    "definition": "An edge which is in a matching.",
    "alsoKnownAs": null,
    "text": "matched edge"
  },
  "matched vertex": {
    "definition": "A vertex on an matched edge in a matching, or, one which has been matched.",
    "alsoKnownAs": null,
    "text": "matched vertex"
  },
  "matching": {
    "definition": "(1) A subgraph in which every vertex has a degree at most one.  In other words, no two edges share a common vertex.   (2) The problem of finding such a subgraph.",
    "alsoKnownAs": null,
    "text": "matching"
  },
  "matrix": {
    "definition": "A two-dimensional array.  By convention, the first index is the row, and the second index is the column.",
    "alsoKnownAs": null,
    "text": "matrix"
  },
  "matrix-chain multiplication problem": {
    "definition": "Given a sequence of matrices such that any matrix may be multiplied by the previous matrix, find the best association such that the result is obtained with the minimum  number of arithmetic operations.  One may use dynamic programming to find the best association.",
    "alsoKnownAs": null,
    "text": "matrix-chain multiplication problem"
  },
  "matrix multiplication": {
    "definition": "A binary operation that takes a pair of matrices. The number of columns in the first matrix must be equal to the number of rows in the second matrix.",
    "alsoKnownAs": null,
    "text": "matrix multiplication"
  },
  "max-heap property": {
    "definition": "Each node in a tree has a key which is less than or equal to the key of its parent.",
    "alsoKnownAs": null,
    "text": "max-heap property"
  },
  "maximal independent set": {
    "definition": "A set of vertices in a graph such that for any pair of vertices, there is no edge between them and such that no more vertices can be added and it still be an independent set.",
    "alsoKnownAs": null,
    "text": "maximal independent set"
  },
  "maximally connected component": {
    "definition": "A connected subgraph of a graph to which no vertex can be added and it still be connected.",
    "alsoKnownAs": null,
    "text": "maximally connected component"
  },
  "maximum-flow problem": {
    "definition": "The problem of finding the maximum flow between any two  vertices of a directed graph.",
    "alsoKnownAs": "network flow problem.",
    "text": "maximum-flow problem"
  },
  "Mealy machine": {
    "definition": "A finite state machine which produces an output for each transition.",
    "alsoKnownAs": null,
    "text": "Mealy machine"
  },
  "mean": {
    "definition": "The (arithmetic) mean of some values is the sum of all values divided by the number of values.",
    "alsoKnownAs": null,
    "text": "mean"
  },
  "median": {
    "definition": "The value that has an equal number of values greater and less than it.  For an even number of values, it is the mean of the two middle values.",
    "alsoKnownAs": null,
    "text": "median"
  },
  "meld": {
    "definition": "Joining several data structures with particular properties into one large data structure having those properties.  For instance, some priority queue implementations support the operation of joining two priority queues into a larger one.",
    "alsoKnownAs": null,
    "text": "meld"
  },
  "memoization": {
    "definition": "Save (memoize) a computed answer for possible later reuse, rather than recomputing the answer.",
    "alsoKnownAs": null,
    "text": "memoization"
  },
  "merge": {
    "definition": "Combine two or more sorted sequences of data into a single sorted  sequence.",
    "alsoKnownAs": null,
    "text": "merge"
  },
  "merge sort": {
    "definition": "A sort algorithm that splits the items to be sorted into two groups, recursively sorts each group, and  merges them into a final, sorted sequence.   Run time is Θ(n log n).",
    "alsoKnownAs": null,
    "text": "merge sort"
  },
  "Merkle tree": {
    "definition": "A tree (usually a binary tree) in which each internal node has a hash of all the information in the leaf nodes under it.  Specifically, each internal node has a hash of the information in its children.  Each leaf has a hash of the block of information it represents.  All leaf nodes are at the same depth.  All nodes are as far left as possible.",
    "alsoKnownAs": "hash tree.",
    "text": "Merkle tree"
  },
  "metaheuristic": {
    "definition": "(1) A high-level algorithmic framework or approach that can be specialized to solve optimization problems.  (2) A high-level strategy that guides other heuristics in a search for feasible solutions.",
    "alsoKnownAs": null,
    "text": "metaheuristic"
  },
  "metaphone": {
    "definition": "An algorithm to code English words phonetically by reducing them to 16 consonant sounds.  A better variant is double metaphone.",
    "alsoKnownAs": null,
    "text": "metaphone"
  },
  "midrange": {
    "definition": "The sum of the minimum and maximum values, divided by two.",
    "alsoKnownAs": null,
    "text": "midrange"
  },
  "Miller-Rabin": {
    "definition": "A heuristic test for prime numbers.  It repeatedly checks if the number being tested, n, is pseudoprime to a randomly chosen base, a, and there are only trivial square roots of 1, modulo n.  In other words, n is surely composite if an-1 ≠ 1 (mod n), where 0 < a < n.  Some composites may be incorrectly judged to be prime.",
    "alsoKnownAs": null,
    "text": "Miller-Rabin"
  },
  "min-heap property": {
    "definition": "Each node in a tree has a key which is greater than or equal to the key of its parent.",
    "alsoKnownAs": null,
    "text": "min-heap property"
  },
  "minimal perfect hashing": {
    "definition": "A perfect hashing function that maps each different key to a distinct integer and has the same number of possible integers as keys.",
    "alsoKnownAs": null,
    "text": "minimal perfect hashing"
  },
  "minimax": {
    "definition": "Generate all nodes in a game tree.  Score each leaf node with its utility value.  Score each minimizing node with the smallest of its   children's scores, and maximizing node with the largest of its children's scores.",
    "alsoKnownAs": null,
    "text": "minimax"
  },
  "minimum bounding box": {
    "definition": "The smallest rectangle completely enclosing a set of points.",
    "alsoKnownAs": "MBB.",
    "text": "minimum bounding box"
  },
  "minimum cut": {
    "definition": "The smallest set of edges in an undirected graph which separate two distinct vertices.  That is, every path between them includes some member of the set.",
    "alsoKnownAs": null,
    "text": "minimum cut"
  },
  "minimum spanning tree": {
    "definition": "A minimum-weight tree in a weighted graph which contains all of the graph's vertices.",
    "alsoKnownAs": "MST, shortest spanning tree, SST.",
    "text": "minimum spanning tree"
  },
  "minimum vertex cut": {
    "definition": "The smallest set of vertices in an undirected graph which separate two distinct vertices.  That is, every path between them passes through some member of the cut.",
    "alsoKnownAs": null,
    "text": "minimum vertex cut"
  },
  "mixed integer linear program": {
    "definition": "A linear program with additional constraints that some of the variables must take on integer values.  Solving such problems is NP-hard.",
    "alsoKnownAs": null,
    "text": "mixed integer linear program"
  },
  "mode": {
    "definition": "The value that occurs most often.  If no value is repeated, there is no mode.  If more than one value occurs with the same greatest frequency, each value is a mode.",
    "alsoKnownAs": null,
    "text": "mode"
  },
  "model checking": {
    "definition": "Efficiently deciding whether a temporal logic formula is satisfied in a finite state machine model.",
    "alsoKnownAs": null,
    "text": "model checking"
  },
  "model of computation": {
    "definition": "A formal, abstract definition of a computer.  Using a model one can more easily analyze the intrinsic execution time or memory space of an algorithm while ignoring many implementation issues.  There are many models of computation which differ in computing power (that is, some models can perform computations impossible for other models) and the cost of various operations.",
    "alsoKnownAs": null,
    "text": "model of computation"
  },
  "moderately exponential": {
    "definition": "The measure of computation, m(n) (usually execution time or memory space), is more than any polynomial nk, but less than any exponential cn where c > 1.  Formally, m(n) is of moderately exponential growth if ∀ k  > 0 m(n)=Ω(nk) and ∀ ε  > 0 m(n)=o((1+ε)n).",
    "alsoKnownAs": null,
    "text": "moderately exponential"
  },
  "MODIFIND": {
    "definition": "Select the kth smallest element of an array and partition the array around it.  Partition around the value of the kth element.  If the partition boundary is not at k, repeat in the partition that includes k.",
    "alsoKnownAs": null,
    "text": "MODIFIND"
  },
  "monotone priority queue": {
    "definition": "A priority queue in which a key being inserted is never higher in priority than a previously deleted node.",
    "alsoKnownAs": null,
    "text": "monotone priority queue"
  },
  "monotonically decreasing": {
    "definition": "A function from a partially ordered domain to a partially ordered range such that x ≤ y implies f(x) ≥ f(y).",
    "alsoKnownAs": null,
    "text": "monotonically decreasing"
  },
  "monotonically increasing": {
    "definition": "A function from a partially ordered domain to a partially ordered range such that x ≤ y implies f(x) ≤ f(y).",
    "alsoKnownAs": null,
    "text": "monotonically increasing"
  },
  "Monte Carlo algorithm": {
    "definition": "A randomized algorithm that may produce incorrect results, but with bounded error probability.",
    "alsoKnownAs": null,
    "text": "Monte Carlo algorithm"
  },
  "Moore machine": {
    "definition": "A finite state machine that produces an output for each state.",
    "alsoKnownAs": null,
    "text": "Moore machine"
  },
  "move-to-front heuristic": {
    "definition": "A heuristic that moves the target of a search to the head of a list so it is found faster next time.",
    "alsoKnownAs": null,
    "text": "move-to-front heuristic"
  },
  "move-to-root heuristic": {
    "definition": "A heuristic that moves the target of a search to the root of the search tree so it is found faster next time.",
    "alsoKnownAs": null,
    "text": "move-to-root heuristic"
  },
  "multi-commodity flow": {
    "definition": "A maximum-flow problem involving multiple commodities, in which each commodity has an associated demand and source-sink pairs.",
    "alsoKnownAs": null,
    "text": "multi-commodity flow"
  },
  "multigraph": {
    "definition": "A graph whose edges are unordered pairs of  vertices, and the same pair of vertices can be connected by multiple edges.",
    "alsoKnownAs": null,
    "text": "multigraph"
  },
  "multikey Quicksort": {
    "definition": "Pick an element from the array (the pivot).  Consider the first character (key) of the string (multikey).  Partition the remaining elements into three sets: those whose corresponding character is less than, equal to, and greater than the pivot's character.  Recursively sort the \"less than\" and \"greater than\" partitions on the same character. Recursively sort the \"equal to\" partition by the next character (key).",
    "alsoKnownAs": "three-way radix quicksort.",
    "text": "multikey Quicksort"
  },
  "multilayer grid file": {
    "definition": "A spatial access method which is two or more simultaneous grid files.  Objects reside in the first grid file where it doesn't have to be split across hyperplanes.",
    "alsoKnownAs": null,
    "text": "multilayer grid file"
  },
  "multiplication method": {
    "definition": "A hash function that uses the first p bits of the key times an irrational number.",
    "alsoKnownAs": null,
    "text": "multiplication method"
  },
  "multiprefix": {
    "definition": "A generalization of scan in which the partial sums are grouped by keys.",
    "alsoKnownAs": null,
    "text": "multiprefix"
  },
  "multiprocessor model": {
    "definition": "A model of parallel computation based on a set of communicating sequential processors.",
    "alsoKnownAs": null,
    "text": "multiprocessor model"
  },
  "multi suffix tree": {
    "definition": "A suffix tree extended to multiple strings by concatenating the strings.",
    "alsoKnownAs": null,
    "text": "multi suffix tree"
  },
  "multiway decision": {
    "definition": "A decision which has more than two results.  For instance, testing if a < b yields two results, but some languages allow a test to return a < b, a=b, or a > b in one operation.",
    "alsoKnownAs": null,
    "text": "multiway decision"
  },
  "multiway merge": {
    "definition": "Combine more than two sorted data streams into a single sorted stream.",
    "alsoKnownAs": null,
    "text": "multiway merge"
  },
  "multiway tree": {
    "definition": "A tree with any number of children for each  node.",
    "alsoKnownAs": null,
    "text": "multiway tree"
  },
  "Munkres' assignment algorithm": {
    "definition": "Solve the assignment problem in polynomial time by marking and unmarking entries and covering and uncovering rows and columns.",
    "alsoKnownAs": "Hungarian algorithm.",
    "text": "Munkres' assignment algorithm"
  },
  "nand": {
    "definition": "Negated conjunction: 0 NAND 0 = 1, 0 NAND 1 = 1, 1 NAND 0 = 1, 1 NAND 1 = 0.",
    "alsoKnownAs": null,
    "text": "nand"
  },
  "n-ary function": {
    "definition": "(1) A function with exactly n arguments.  (2) A function which takes any number of arguments, or a variable number of arguments.",
    "alsoKnownAs": null,
    "text": "n-ary function"
  },
  "NC many-one reducibility": {
    "definition": "A language L is NC many-one reducible or NC reducible to L', written L ≤mNC L' if there is a function f in FNC such that x ∈ L if and only if f(x) ∈ L'.",
    "alsoKnownAs": null,
    "text": "NC many-one reducibility"
  },
  "nearest neighbor": {
    "definition": "Find the point (rectangle, line, etc.) that is closest to another point.",
    "alsoKnownAs": null,
    "text": "nearest neighbor"
  },
  "negation": {
    "definition": "The negation of 0 is 1; the negation of 1 is 0.",
    "alsoKnownAs": null,
    "text": "negation"
  },
  "next state": {
    "definition": "The state immediately following the current state, defined by the transition function of a finite state machine and the input.",
    "alsoKnownAs": null,
    "text": "next state"
  },
  "NIST": {
    "definition": "The United States National Institute of Standards and Technology.",
    "alsoKnownAs": null,
    "text": "NIST"
  },
  "node": {
    "definition": "(1) A unit of reference in a data structure.  Also called a vertex in graphs and trees. (2) A collection of information which must be kept at a single memory location.",
    "alsoKnownAs": null,
    "text": "node"
  },
  "nonbalanced merge sort": {
    "definition": "A k-way merge sort in which the number of input and  output data streams is different for any particular  pass.  Typically P input streams are merged and distributed to T output streams on one pass followed by a merge of the T inputs and distribution to P outputs.",
    "alsoKnownAs": null,
    "text": "nonbalanced merge sort"
  },
  "nondeterministic": {
    "definition": "Permitting more than one choice of next move at some step in a computation.",
    "alsoKnownAs": null,
    "text": "nondeterministic"
  },
  "nondeterministic algorithm": {
    "definition": "A conceptual algorithm with more than one allowed step at certain times and which always takes the right or best step.   It is not random, as in randomized algorithm, or indeterminate. Rather it has the supercomputational characteristic of choosing the optimal behavior.",
    "alsoKnownAs": null,
    "text": "nondeterministic algorithm"
  },
  "nondeterministic finite state machine": {
    "definition": "A finite state machine whose transition function maps inputs symbols and states to a (possibly empty) set of next states.  The transition function also may map the null symbol (no input symbol needed) and states to next states.",
    "alsoKnownAs": "NFA, nondeterministic finite automaton.",
    "text": "nondeterministic finite state machine"
  },
  "nondeterministic finite tree automaton": {
    "definition": "A nondeterministic finite state machine that accepts finitary trees rather than just strings.  The tree nodes are marked with the letters of the alphabet of the automaton, and the transition function encodes the next states for each branch of the tree.  The acceptance condition is modified accordingly.",
    "alsoKnownAs": "NFTA.",
    "text": "nondeterministic finite tree automaton"
  },
  "nondeterministic tree automaton": {
    "definition": "A nondeterministic finite state machine that accepts infinite trees rather than just strings.  The tree nodes are marked with the letters of the alphabet of the automaton, and the transition function encodes the next states for each branch of the tree.  The expressive power of such automata varies depending on the acceptance conditions of the trees.",
    "alsoKnownAs": null,
    "text": "nondeterministic tree automaton"
  },
  "nondeterministic Turing machine": {
    "definition": "A Turing machine which has more than one next state for some combinations of contents of the current cell and current state.  An input is accepted if any move sequence leads to acceptance.",
    "alsoKnownAs": null,
    "text": "nondeterministic Turing machine"
  },
  "nor": {
    "definition": "Negated disjunction: 0 NOR 0 = 1, 0 NOR 1 = 0, 1 NOR 0 = 0, 1 NOR 1 = 0.",
    "alsoKnownAs": null,
    "text": "nor"
  },
  "not": {
    "definition": "Negation: NOT 0 = 1, NOT 1 = 0.  Also known as complement.",
    "alsoKnownAs": null,
    "text": "not"
  },
  "NP": {
    "definition": "The complexity class of decision problems for which answers can be checked by an algorithm whose run time is  polynomial in the size of the input.  Note that this doesn't require or imply that an answer can be found quickly, only that any claimed solution can be verified quickly.  \"NP\" is the class that a Nondeterministic Turing machine accepts in Polynomial time.",
    "alsoKnownAs": "nondeterministic polynomial time.",
    "text": "NP"
  },
  "NP-complete": {
    "definition": "The complexity class of decision problems for which answers can be checked for correctness, given a certificate, by an algorithm whose run time is polynomial in the size of the input (that is, it is NP) and no other NP problem is more than a polynomial factor harder. Informally, a problem is NP-complete if answers can be verified quickly, and a quick algorithm to solve this problem can be used to solve all other NP problems quickly.",
    "alsoKnownAs": null,
    "text": "NP-complete"
  },
  "NP-complete language": {
    "definition": "A language in NP such that every language in NP can be reduced to it in polynomial time.",
    "alsoKnownAs": null,
    "text": "NP-complete language"
  },
  "NP-hard": {
    "definition": "The complexity class of decision problems that are intrinsically harder than those that can be solved by a nondeterministic Turing machine in polynomial time.  When a decision version of a combinatorial optimization problem is proved to belong to the class of NP-complete problems,  then the optimization version is NP-hard.",
    "alsoKnownAs": null,
    "text": "NP-hard"
  },
  "n queens": {
    "definition": "Place n chess queens on an n × n board such that no queen can attack another.  Efficiently find all possible placements.",
    "alsoKnownAs": null,
    "text": "n queens"
  },
  "null tree": {
    "definition": "(1) A tree which is empty.  (2) A tree whose leaf nodes all have a null value.",
    "alsoKnownAs": null,
    "text": "null tree"
  },
  "NYSIIS": {
    "definition": "Convert a name to a phonetic coding of up to six characters.",
    "alsoKnownAs": null,
    "text": "NYSIIS"
  },
  "objective function": {
    "definition": "A function associated with an optimization problem which determines how good a solution is, for instance, the total cost of edges in a solution to a traveling salesman problem.",
    "alsoKnownAs": null,
    "text": "objective function"
  },
  "oblivious algorithm": {
    "definition": "An algorithm whose behavior, by design, is independent of some property that influences a typical algorithm for the same problem.",
    "alsoKnownAs": null,
    "text": "oblivious algorithm"
  },
  "occurrence": {
    "definition": "A string v occurs in a string u if v is a substring of u.",
    "alsoKnownAs": null,
    "text": "occurrence"
  },
  "octree": {
    "definition": "A tree to index three dimensions.  Each node has either eight children or no children.",
    "alsoKnownAs": null,
    "text": "octree"
  },
  "off-line algorithm": {
    "definition": "An algorithm which is given the entire sequence of inputs in advance.",
    "alsoKnownAs": null,
    "text": "off-line algorithm"
  },
  "offset": {
    "definition": "The distance from the beginning of a string to the end of a segment in that string.",
    "alsoKnownAs": null,
    "text": "offset"
  },
  "omega": {
    "definition": "The Greek letter written as  ω (see ω(n)) or Ω (see Ω(n)).",
    "alsoKnownAs": null,
    "text": "omega"
  },
  "omicron": {
    "definition": "The Greek letter written as \"o\" (see little-o notation) or \"O\" (see big-O notation).",
    "alsoKnownAs": null,
    "text": "omicron"
  },
  "1-based indexing": {
    "definition": "Indexing (an array) beginning with 1.",
    "alsoKnownAs": null,
    "text": "1-based indexing"
  },
  "one-dimensional": {
    "definition": "Dealing with or restricted to a line.  An organization where location can be completely described with exactly one axis.",
    "alsoKnownAs": null,
    "text": "one-dimensional"
  },
  "on-line algorithm": {
    "definition": "An algorithm that must process each input in turn, without detailed knowledge of future inputs.",
    "alsoKnownAs": null,
    "text": "on-line algorithm"
  },
  "open addressing": {
    "definition": "A class of collision resolution schemes in which all items are stored within the hash table.  In case of collision, other positions are computed, giving a probe sequence, and checked until an empty position is found.  Some ways of computing possible new positions are less efficient because of clustering. Typically items never move once put in place, but in Robin Hood hashing, LCFS hashing, and other techniques,  previously placed items may move.",
    "alsoKnownAs": null,
    "text": "open addressing"
  },
  "optimal": {
    "definition": "(1) A solution to an optimization problem which has the minimum (or maximum) value of the objective function.  (2) The time, space, resource, etc. complexity of an algorithm which matches the best known lower bound of a problem.",
    "alsoKnownAs": null,
    "text": "optimal"
  },
  "optimal merge": {
    "definition": "Merge n sorted sequences of different lengths into one output while minimizing reads.  Only two sequences can be merged at once.  At each step, the two shortest sequences are merged.",
    "alsoKnownAs": null,
    "text": "optimal merge"
  },
  "optimal mismatch": {
    "definition": "A string matching algorithm that compares the rarest character first.  When a character doesn't match, the next character in the text beyond the search string determines where the next possible match begins.",
    "alsoKnownAs": null,
    "text": "optimal mismatch"
  },
  "optimal polyphase merge": {
    "definition": "A polyphase merge which seeks to minimize the number of merge passes by allocating output runs of each pass to the various output files.  Since polyphase merging must have a different number of runs in each file to be efficient, one seeks the optimal way of selecting how many runs go into each output file.  A series of kth order Fibonacci numbers is one way to select the number of runs.",
    "alsoKnownAs": null,
    "text": "optimal polyphase merge"
  },
  "optimal polyphase merge sort": {
    "definition": "An external sort algorithm that uses optimal polyphase merges.",
    "alsoKnownAs": null,
    "text": "optimal polyphase merge sort"
  },
  "optimal solution": {
    "definition": "A solution to an optimization problem which minimizes (or maximizes) the objective function.",
    "alsoKnownAs": null,
    "text": "optimal solution"
  },
  "optimal triangulation problem": {
    "definition": "Find the triangulation with the greatest overall minimum angle. There is an incremental algorithm that takes O(n log n) time.",
    "alsoKnownAs": null,
    "text": "optimal triangulation problem"
  },
  "optimal value": {
    "definition": "The minimum (or maximum) value of the objective function over the feasible region of an optimization problem.",
    "alsoKnownAs": null,
    "text": "optimal value"
  },
  "optimization problem": {
    "definition": "A computational problem in which the object is to find the best of all possible solutions.  More formally, find a solution in the feasible region which has the minimum (or maximum) value of the objective function.",
    "alsoKnownAs": null,
    "text": "optimization problem"
  },
  "or": {
    "definition": "Disjunction: 0 OR 0 = 0, 0 OR 1 = 1, 1 OR 0 = 1, 1 OR 1 = 1.",
    "alsoKnownAs": "inclusive or.",
    "text": "or"
  },
  "oracle set": {
    "definition": "A predetermined set of tapes used by an oracle Turing machine to make decisions otherwise not feasibled.",
    "alsoKnownAs": null,
    "text": "oracle set"
  },
  "oracle tape": {
    "definition": "An extra tape used by an oracle Turing machine to make decisions otherwise not feasible.",
    "alsoKnownAs": null,
    "text": "oracle tape"
  },
  "oracle Turing machine": {
    "definition": "A Turing machine with an extra oracle tape and three extra states q?, qy, qn.  When the machine enters q?, control goes to state qy if the oracle tape content is in the oracle set; otherwise control goes to state qn.",
    "alsoKnownAs": null,
    "text": "oracle Turing machine"
  },
  "order": {
    "definition": "(1) The height of a tree.   (2) The number of children of the root of a binomial tree. (3) The maximum number of children of nodes in a B-tree. (4) The number of data streams, usually denoted ω, in a multiway merge.",
    "alsoKnownAs": null,
    "text": "order"
  },
  "ordered array": {
    "definition": "An array whose items have some order.  Usually, it means a sorted array, but may mean not fully ordered, for example, all values less than the median are in the first half.",
    "alsoKnownAs": null,
    "text": "ordered array"
  },
  "ordered linked list": {
    "definition": "A linked list whose items are kept in some order.",
    "alsoKnownAs": null,
    "text": "ordered linked list"
  },
  "ordered tree": {
    "definition": "A tree where the children of every node are ordered, that is, there is a first child, second child, third child, etc.",
    "alsoKnownAs": null,
    "text": "ordered tree"
  },
  "order-preserving Huffman coding": {
    "definition": "A variable-length character coding based on the frequency of each character.  The algorithm is similar to Huffman coding, but the trees are kept in the same order as the characters.  Two adjacent trees with the least combined frequency are joined as subtrees of a new root.  As with Huffman coding, that new tree is assigned the sum of the subtrees' frequencies.  Repeat until all characters are in one tree.",
    "alsoKnownAs": null,
    "text": "order-preserving Huffman coding"
  },
  "order-preserving minimal perfect hashing": {
    "definition": "A minimal perfect hashing function for keys in S such that if k1, k2 ∈ S and k1 > k2, then f(k1) > f(k2).",
    "alsoKnownAs": null,
    "text": "order-preserving minimal perfect hashing"
  },
  "orthogonal drawing": {
    "definition": "A graph drawing in which each edge is represented by a polyline, each segment of which is parallel to a coordinate axis.",
    "alsoKnownAs": null,
    "text": "orthogonal drawing"
  },
  "orthogonal lists": {
    "definition": "Lists that share items, but are structurally independent.",
    "alsoKnownAs": null,
    "text": "orthogonal lists"
  },
  "orthogonally convex rectilinear polygon": {
    "definition": "A rectilinear polygon P in which every horizontal or vertical segment connecting two points in P lies totally within P.",
    "alsoKnownAs": null,
    "text": "orthogonally convex rectilinear polygon"
  },
  "oscillating merge sort": {
    "definition": "Given n tape drives, one input and n-1 work drives, distribute a portion of the input to n-2 tapes, then merge them onto the final tape reading the n-2 backward.  Repeat until n-2 (backward) merged runs have been created, at which time they are  merged.  Continue building up powers of n-2 batches until done.",
    "alsoKnownAs": null,
    "text": "oscillating merge sort"
  },
  "out-degree": {
    "definition": "The number of edges going out of a vertex in a directed graph.",
    "alsoKnownAs": null,
    "text": "out-degree"
  },
  "P": {
    "definition": "The complexity class of languages that can be accepted by a deterministic Turing machine in polynomial time.",
    "alsoKnownAs": null,
    "text": "P"
  },
  "packing": {
    "definition": "Given a finite collection of subsets of a finite ground set, to find an optimal subcollection that are pairwise disjoint.",
    "alsoKnownAs": null,
    "text": "packing"
  },
  "padding argument": {
    "definition": "A method for transferring results about one complexity bound to another complexity bound, by padding extra dummy characters onto the inputs of the machines involved.",
    "alsoKnownAs": null,
    "text": "padding argument"
  },
  "pagoda": {
    "definition": "A priority queue implemented with a variant of a binary tree.  The root points to its children, as in a binary tree.  Every other node points back to its parent and down to its leftmost (if it is a right child) or rightmost (if it is a left child) descendant leaf.  The basic operation is merge or meld, which maintains  the heap property.  An element is inserted by merging it as a singleton.  The root is removed by merging its right and left children.  Merging is bottom-up, merging the leftmost edge of one with the rightmost edge of the other.",
    "alsoKnownAs": null,
    "text": "pagoda"
  },
  "parallel computation thesis": {
    "definition": "Sequential space is a polynomial of parallel time.",
    "alsoKnownAs": null,
    "text": "parallel computation thesis"
  },
  "parallel prefix computation": {
    "definition": "Calculate an associative function, f, on all prefixes of an n-element array, that is, s[0], f(s[0], s[1]), f(s[0], f(s[1], s[2])), …, f(s[0], f(s[1], … f(s[n-2], s[n-1])…)),  using Θ(n) processors in Θ(log n) time. The algorithm is",
    "alsoKnownAs": null,
    "text": "parallel prefix computation"
  },
  "parallel random-access machine": {
    "definition": "A shared memory model of computation, where typically the processors all execute the same instruction synchronously, and access to any memory location occurs in unit time.",
    "alsoKnownAs": "PRAM.",
    "text": "parallel random-access machine"
  },
  "parent": {
    "definition": "Of a node: the tree node conceptually above or closer to the root than the node and which has a link to the node.  See the figure at tree.",
    "alsoKnownAs": null,
    "text": "parent"
  },
  "partial function": {
    "definition": "A function which is not defined for some inputs of the right type, that is, for some of a domain.  For instance, division is a partial function since division by 0 is undefined (on the Reals).",
    "alsoKnownAs": null,
    "text": "partial function"
  },
  "partially decidable problem": {
    "definition": "One whose associated language is a recursively enumerable language.  Equivalently, there exists an algorithm that halts and outputs 1 for every instance having a \"yes\" answer, but for instances having a \"no\" answer is allowed either not to halt or to halt and output 0.",
    "alsoKnownAs": null,
    "text": "partially decidable problem"
  },
  "partially dynamic graph problem": {
    "definition": "Problem where the update operations include either edge insertions (incremental) or deletions (decremental).",
    "alsoKnownAs": null,
    "text": "partially dynamic graph problem"
  },
  "partially persistent data structure": {
    "definition": "A persistent data structure that allows updates to the latest version only.",
    "alsoKnownAs": null,
    "text": "partially persistent data structure"
  },
  "partial order": {
    "definition": "An order defined for some, but not necessarily all, pairs of items.  For instance, the sets {a, b} and {a, c, d} are subsets of {a, b, c, d}, but neither is a subset of the other.  So  \"subset of\" is a partial order on sets.",
    "alsoKnownAs": null,
    "text": "partial order"
  },
  "partial recursive function": {
    "definition": "A function computed by a Turing machine that need not halt for all inputs.",
    "alsoKnownAs": null,
    "text": "partial recursive function"
  },
  "partition": {
    "definition": "(1) A division of a set into nonempty disjoint sets that completely cover the set.  (2) To rearrange the elements of an array into two (or more) groups, typically, such that elements in the first group are less than a value and elements in the second group are greater.",
    "alsoKnownAs": null,
    "text": "partition"
  },
  "passive data structure": {
    "definition": "A data structure that is only changed by external threads or processes, in contrast to an active data structure.",
    "alsoKnownAs": null,
    "text": "passive data structure"
  },
  "path": {
    "definition": "A list of vertices of a graph where each vertex has an edge between it and the next vertex.",
    "alsoKnownAs": null,
    "text": "path"
  },
  "path system problem": {
    "definition": "For a path system P=(x,R,S,T), where S⊆ X, T ⊆ X, and R⊆ X × X × X, the problem of whether there is an admissible vertex in S.  A vertex is admissible if and only if x∈ T, or there exists admissible y, z ∈ X such that (x,y,z) ∈ R.",
    "alsoKnownAs": null,
    "text": "path system problem"
  },
  "Patricia tree": {
    "definition": "A compact representation of a trie in which any node that is an only child is merged with its  parent.",
    "alsoKnownAs": "radix tree.",
    "text": "Patricia tree"
  },
  "pattern": {
    "definition": "A finite number of strings that are searched for in texts.",
    "alsoKnownAs": null,
    "text": "pattern"
  },
  "pattern element": {
    "definition": "A positive (negative) pattern element is a \"partial wild card\" presented as a subset of the alphabet Σ, with the symbols in the subset specifying which symbols of Σ are matched (mismatched) by the pattern element.",
    "alsoKnownAs": null,
    "text": "pattern element"
  },
  "P-complete": {
    "definition": "A language L is P-hard under NC many-one reducibility if L' ≤mNC for every L' ∈ P.  A language L is P-complete under NC reducibility if L ∈  P and L is P-hard.",
    "alsoKnownAs": null,
    "text": "P-complete"
  },
  "Pearson's hash": {
    "definition": "A hash function that uses an auxiliary array, but no shift or exclusive-or (xor) operations.",
    "alsoKnownAs": null,
    "text": "Pearson's hash"
  },
  "perfect binary tree": {
    "definition": "A binary tree with all leaf nodes at the same depth. All internal nodes have degree 2.",
    "alsoKnownAs": null,
    "text": "perfect binary tree"
  },
  "perfect hashing": {
    "definition": "A hash function that maps each different key to a distinct integer.  Usually all possible keys must be known beforehand.  A hash table that uses a perfect hash has no collisions.",
    "alsoKnownAs": "optimal hashing.",
    "text": "perfect hashing"
  },
  "perfect k-ary tree": {
    "definition": "A k-ary tree with all leaf nodes at same depth. All internal nodes have degree k.",
    "alsoKnownAs": null,
    "text": "perfect k-ary tree"
  },
  "perfect matching": {
    "definition": "A matching, or subset of edges without common vertices, of a connected graph that touches all vertices exactly once.  A graph with an odd number of vertices is allowed one unmatched vertex.",
    "alsoKnownAs": null,
    "text": "perfect matching"
  },
  "perfect shuffle": {
    "definition": "Split a list of elements (or deck of cards) exactly in half then precisely interleave the two halves.",
    "alsoKnownAs": null,
    "text": "perfect shuffle"
  },
  "performance guarantee": {
    "definition": "An expression of the most the result of an approximation algorithm may depart from the optimal solution.",
    "alsoKnownAs": null,
    "text": "performance guarantee"
  },
  "permutation": {
    "definition": "A rearrangement of elements, where none are lost, added, or changed.  The Fisher-Yates shuffle randomly permutes elements.",
    "alsoKnownAs": "shuffle.",
    "text": "permutation"
  },
  "permutation sort": {
    "definition": "A terribly inefficient sort algorithm that generates each permutation of the items until the items are in order.",
    "alsoKnownAs": null,
    "text": "permutation sort"
  },
  "persistent data structure": {
    "definition": "A data structure that preserves its old versions, that is, previous versions may be queried in addition to the latest version.",
    "alsoKnownAs": null,
    "text": "persistent data structure"
  },
  "phonetic coding": {
    "definition": "Code a string based on how it is pronounced.",
    "alsoKnownAs": null,
    "text": "phonetic coding"
  },
  "pigeonhole sort": {
    "definition": "A 2-pass sort algorithm that is efficient when the range of keys is approximately equal to the number of items.  The first pass allocates an array of buckets, one bucket for each possible key value, then moves each item to its key's bucket.  The second pass goes over the bucket array moving each item to the next place in the destination.",
    "alsoKnownAs": null,
    "text": "pigeonhole sort"
  },
  "pile": {
    "definition": "An ordered deque, that is, items may only be added  to or removed from the head or the tail. An item is added to the head if it is smaller than the current head.  An item is added to the tail if it is greater than the current tail.  Items are never inserted into the  middle, rather, an additional pile may be created.",
    "alsoKnownAs": null,
    "text": "pile"
  },
  "pipelined divide and conquer": {
    "definition": "A divide and conquer paradigm in which partial results from recursive calls can be used before the calls complete. The technique is often useful for reducing the depth of an algorithm.",
    "alsoKnownAs": null,
    "text": "pipelined divide and conquer"
  },
  "planar graph": {
    "definition": "A graph that can be drawn in the plane with no  crossing edges.",
    "alsoKnownAs": null,
    "text": "planar graph"
  },
  "planarization": {
    "definition": "The process of transforming a graph into a planar graph. More formally, the transformation involves either removing edges (planarization by edge removal), or replacing pairs of nonincident edges by 4-starts (planarization by adding crossing vertices).  In both cases, the aim of planarization is minimize the number of edge removals or replacements.",
    "alsoKnownAs": null,
    "text": "planarization"
  },
  "planar straight-line graph": {
    "definition": "A graph that can be embedded in the plane without crossings in which every edge in the graph is a straight line segment.  It is sometimes referred to as planar subdivision or map.",
    "alsoKnownAs": null,
    "text": "planar straight-line graph"
  },
  "PLOP-hashing": {
    "definition": "Piecewise linear order-preserving (PLOP) hashing is a spatial access method which splits space into a nonperiodic grid.  Each spatial dimension is divided by nodes of a binary tree.  Object are stored in the grid cell of their centroid.",
    "alsoKnownAs": null,
    "text": "PLOP-hashing"
  },
  "point access method": {
    "definition": "A data structure and associated algorithms primarily to search for points defined in multidimensional space.",
    "alsoKnownAs": "PAM.",
    "text": "point access method"
  },
  "pointer jumping": {
    "definition": "In a linked structure, replacing a pointer with the pointer it points to.  Used for various algorithms on lists and trees.",
    "alsoKnownAs": "recursive doubling, shortcutting.",
    "text": "pointer jumping"
  },
  "pointer machine": {
    "definition": "A model of computation whose memory consists of an unbounded collection of registers, or records, connected by pointers.  Each register may contain an arbitrary amount of additional information.  No arithmetic is allowed to compute the address of a register. The only way to access a register is by following pointers.",
    "alsoKnownAs": null,
    "text": "pointer machine"
  },
  "poissonization": {
    "definition": "To replace a deterministic input by poisson process, changing the model into a poisson model.  A solution to the poisson model must be interpreted in the original model.",
    "alsoKnownAs": null,
    "text": "poissonization"
  },
  "polychotomy": {
    "definition": "Division into many distinct classifications.",
    "alsoKnownAs": null,
    "text": "polychotomy"
  },
  "polyhedron": {
    "definition": "The set of solutions to a finite system of linear inequalities on real-valued variables.  Equivalently, the intersection of a finite number of linear half-spaces in ℜn.",
    "alsoKnownAs": null,
    "text": "polyhedron"
  },
  "polylogarithmic": {
    "definition": "(1) Any function which is the sum of constants times powers of a logarithm of the argument: f(x)=Σi=0kcilogpi x. (2) In complexity theory, the measure of computation, m(n) (usually execution time or memory space), is bounded by a polylogarithmic function of the problem size, n.  More formally m(n) = O(logk n).",
    "alsoKnownAs": null,
    "text": "polylogarithmic"
  },
  "polynomial": {
    "definition": "(1) Any function which is the sum of constants times powers of the argument: f(x)=Σi=0k cixpi. (2) In complexity theory, the measure of computation, m(n) (usually execution time or memory space), is bounded by a polynomial function of the problem size, n.  More formally m(n) = O(nk).",
    "alsoKnownAs": null,
    "text": "polynomial"
  },
  "polynomial approximation scheme": {
    "definition": "A set of algorithms {Aε| ε > 0}, where each Aε is a (1+ε)-approximation algorithm and the execution time is bounded by a polynomial in the length of the input.  The execution time may depend on the choice of ε.  Sometimes referred to more precisely as polynomial-time approximation scheme.",
    "alsoKnownAs": "PTAS.",
    "text": "polynomial approximation scheme"
  },
  "polynomial hierarchy": {
    "definition": "The classes of languages accepted by k-alternating Turing machines, over all k≥ 0 and with initial state existential or universal.  The bottom level (k=0) is the class  P.  The next level (k=1) comprises  NP and co- NP.",
    "alsoKnownAs": null,
    "text": "polynomial hierarchy"
  },
  "polynomial time": {
    "definition": "When the execution time of a computation, m(n), is no more than a polynomial function of the problem size, n. More formally m(n) = O(nk) where k is a constant.",
    "alsoKnownAs": null,
    "text": "polynomial time"
  },
  "polynomial-time reduction": {
    "definition": "A transformation of one problem into another which is computable in polynomial time.",
    "alsoKnownAs": null,
    "text": "polynomial-time reduction"
  },
  "polyphase merge": {
    "definition": "A nonbalanced k-way merge which reduces the number of output files needed by reusing the emptied input file or device as one of the output devices.  This is most efficient if the number of output runs in each output file is different.",
    "alsoKnownAs": null,
    "text": "polyphase merge"
  },
  "polyphase merge sort": {
    "definition": "A merge sort algorithm that reduces the number of intermediate files needed by reusing emptied files.",
    "alsoKnownAs": null,
    "text": "polyphase merge sort"
  },
  "polytope": {
    "definition": "A closed, bounded N-dimensional figure whose faces are hyperplanes. Informally, a multidimensional solid with flat sides.  A generalization of polyhedron.",
    "alsoKnownAs": null,
    "text": "polytope"
  },
  "poset": {
    "definition": "A set the elements of which are subject to a partial order.",
    "alsoKnownAs": "partially ordered set.",
    "text": "poset"
  },
  "postman's sort": {
    "definition": "A highly engineered variant of top-down radix sort where attributes of the key are described so the algorithm can allocate buckets and distribute efficiently.",
    "alsoKnownAs": null,
    "text": "postman's sort"
  },
  "postorder traversal": {
    "definition": "Process all nodes of a tree by recursively processing all subtrees, then finally processing the root.",
    "alsoKnownAs": "postfix traversal.",
    "text": "postorder traversal"
  },
  "Post's correspondence problem": {
    "definition": "Given a set of pairs of strings, find a sequence of pairs such that the concatenation of all first members of the pairs is the same string as the concatenation of all second members. This is an undecidable problem.",
    "alsoKnownAs": "PCP.",
    "text": "Post's correspondence problem"
  },
  "potential function": {
    "definition": "A measure of a data structure whose change after an operation corresponds to the time cost of the operation.",
    "alsoKnownAs": null,
    "text": "potential function"
  },
  "predicate": {
    "definition": "A function that returns true or false.  Conceptually it tests for a condition.",
    "alsoKnownAs": null,
    "text": "predicate"
  },
  "prefix": {
    "definition": "The beginning characters of a string.  More formally a string v∈Σ* is a prefix of a string u∈Σ* if u=vu' for some string u'∈Σ*.",
    "alsoKnownAs": null,
    "text": "prefix"
  },
  "prefix code": {
    "definition": "Set of words such that no word of the set is a prefix of another word in the set.  A prefix code may be represented by a coding tree.",
    "alsoKnownAs": null,
    "text": "prefix code"
  },
  "preorder traversal": {
    "definition": "Process all nodes of a tree by processing the root, then recursively processing all subtrees.",
    "alsoKnownAs": "prefix traversal.",
    "text": "preorder traversal"
  },
  "primary clustering": {
    "definition": "The tendency for some collision resolution schemes to create long runs of filled slots near the hash function position of keys.",
    "alsoKnownAs": null,
    "text": "primary clustering"
  },
  "primitive algorithm": {
    "definition": "An algorithm in which all the computable steps are basic operations.",
    "alsoKnownAs": null,
    "text": "primitive algorithm"
  },
  "primitive recursive": {
    "definition": "A total function that can be written using only nested conditional (if-then-else) statements and fixed iteration (for) loops.",
    "alsoKnownAs": null,
    "text": "primitive recursive"
  },
  "Prim-Jarnik algorithm": {
    "definition": "Compute a minimum spanning tree by beginning with any vertex as the current tree.  At each step add a least edge between any vertex not in the tree and any vertex in the tree.  Continue until all vertices have been added.",
    "alsoKnownAs": null,
    "text": "Prim-Jarnik algorithm"
  },
  "principle of optimality": {
    "definition": "In some optimization problems, components of a globally optimal solution are themselves globally optimal.",
    "alsoKnownAs": null,
    "text": "principle of optimality"
  },
  "priority queue": {
    "definition": "An abstract data type to efficiently support finding the item with the highest priority across a series of operations.  The basic operations are: insert, find-minimum (or maximum), and delete-minimum (or maximum).  Some implementations also efficiently support join two priority queues (meld), delete an arbitrary item, and increase the priority of a item (decrease-key).",
    "alsoKnownAs": null,
    "text": "priority queue"
  },
  "prisoner's dilemma": {
    "definition": "Two prisoners are questioned separately about a crime they committed.  Each may give evidence against the other or may say nothing.  If both say nothing, they get a minor reprimand and go free because of lack of evidence.  If one gives evidence and the other says nothing, the first goes free and the second is severely punished.  If both give evidence, both are severely punished.  The overall (globally) best strategy is for both to say nothing.  However not knowing (or trusting) what the other will do, each prisoner's (locally) best strategy is to give evidence, which is the worst possible outcome.",
    "alsoKnownAs": null,
    "text": "prisoner's dilemma"
  },
  "probabilistic algorithm": {
    "definition": "Any algorithm that works for all practical purposes but has a theoretical chance of being wrong.",
    "alsoKnownAs": null,
    "text": "probabilistic algorithm"
  },
  "probabilistically checkable proof": {
    "definition": "An interactive proof system in which provers follow a fixed strategy, that is, one not affected by any messages from the verifier.  The prover's strategy for a given instance x of a decision problem can be represented by a finite oracle language Bx, which constitutes a proof of the correct answer for x.",
    "alsoKnownAs": null,
    "text": "probabilistically checkable proof"
  },
  "probabilistic Turing machine": {
    "definition": "A Turing machine in which some transitions are random choices among finitely many alternatives.",
    "alsoKnownAs": null,
    "text": "probabilistic Turing machine"
  },
  "probe sequence": {
    "definition": "The list of locations which a method for open addressing produces as alternatives in case of a collision.",
    "alsoKnownAs": null,
    "text": "probe sequence"
  },
  "procedure": {
    "definition": "A subroutine which does not return a value.",
    "alsoKnownAs": null,
    "text": "procedure"
  },
  "process algebra": {
    "definition": "An algebraic theory to formalize the notion of concurrent computation, best exemplified in CSP and CCS.",
    "alsoKnownAs": null,
    "text": "process algebra"
  },
  "proper": {
    "definition": "(1) A subunit of a unit is not equal to the unit itself.  For instance, a proper substring is not the whole string, a proper subset is not the whole set, a proper subgraph is not the whole graph, etc.  (2) According to a rule, as in proper coloring.",
    "alsoKnownAs": null,
    "text": "proper"
  },
  "proper coloring": {
    "definition": "A vertex coloring or edge coloring of a graph in which no two adjacent vertices or edges have the same color.",
    "alsoKnownAs": null,
    "text": "proper coloring"
  },
  "proper subset": {
    "definition": "A set S2 is a proper subset of another set S1 if every element in S2 is in S1 and S1 has some elements which are not in S2.",
    "alsoKnownAs": null,
    "text": "proper subset"
  },
  "prune and search": {
    "definition": "Find an optimal value by eliminating a constant fraction of remaining objects at each step.  Eliminated objects are guaranteed not to affect the optimal value.  A logarithmic number of steps reduces the number of objects to a constant, and a brute force approach can then solve it.",
    "alsoKnownAs": "decimation.",
    "text": "prune and search"
  },
  "pseudo-random number generator": {
    "definition": "A deterministic algorithm to generate a sequence of numbers with little or no discernible pattern in the numbers, except for broad statistical properties.",
    "alsoKnownAs": "PRNG, deterministic random bit generator, DRBG.",
    "text": "pseudo-random number generator"
  },
  "P-tree": {
    "definition": "(1) A spatial access method that defines hyperplanes, in addition to the orthogonal dimensions, which node boundaries may parallel.  Space is split by hierarchically nested  polytopes (multidimensional boxes with nonrectangular sides).  The R-tree is a special case that has no additional hyperplanes. (2) A spatial access method that splits space by hierarchically nested polytopes. The R-tree is a special case in which all polytopes are boxes.",
    "alsoKnownAs": null,
    "text": "P-tree"
  },
  "purely functional language": {
    "definition": "A language that does not allow any destructive operation---one which overwrites data---such as the assignment operation. Purely functional languages are free of side effects, i.e., invoking a function has no effect other than computing the value returned by the function.",
    "alsoKnownAs": null,
    "text": "purely functional language"
  },
  "pushdown automaton": {
    "definition": "A restricted Turing machine where the tape acts as a pushdown store (or stack, where only the latest element can be read), with an extra one-way read-only input tape.",
    "alsoKnownAs": "PDA.",
    "text": "pushdown automaton"
  },
  "q sort": {
    "definition": "The sort function in many libraries. It is generally a combination of quicksort, for many items, and insertion sort, for a few items.",
    "alsoKnownAs": null,
    "text": "q sort"
  },
  "quadratic probing": {
    "definition": "A method of open addressing for a hash table in which a collision is resolved by putting the item in the next empty place given by a probe sequence.  The space between places in the sequence increases quadratically.",
    "alsoKnownAs": null,
    "text": "quadratic probing"
  },
  "quadtree": {
    "definition": "A tree where each node is split along all d dimensions, leading to 2d children.",
    "alsoKnownAs": null,
    "text": "quadtree"
  },
  "quadtree complexity theorem": {
    "definition": "The number of nodes in a quadtree region representation for a simple polygon (i.e. with nonintersecting edges and without holes) is O(p+q) for a 2q× 2q image with perimeter p measured in pixel widths.  In most cases, q is negligible, and thus, the number of nodes is proportional to the perimeter.  It also holds for three-dimensional data where the perimeter is replaced by surface area, and in general  for d-dimensions where instead of perimeter we have the size of the (d-1)-dimensional interfaces between the d-dimensional objects.",
    "alsoKnownAs": null,
    "text": "quadtree complexity theorem"
  },
  "quad trie": {
    "definition": "A tree in which each node is split according to some subset of the key, typically a character.",
    "alsoKnownAs": null,
    "text": "quad trie"
  },
  "quantum computation": {
    "definition": "Computation based on quantum mechanical effects, such as superposition and entanglement, in addition to classical digital manipulations.",
    "alsoKnownAs": null,
    "text": "quantum computation"
  },
  "queue": {
    "definition": "A collection of items in which only the earliest added item may be accessed.  Basic operations are add (to the tail) or enqueue and delete (from the head) or dequeue.  Delete returns the item removed.  Also known as \"first-in, first-out\" or FIFO.",
    "alsoKnownAs": "FIFO.",
    "text": "queue"
  },
  "quick search": {
    "definition": "A string matching algorithm that compares characters from the end of the search string to its beginning.  When a character doesn't match, the next character in the text beyond the search string determines where the next possible match begins.",
    "alsoKnownAs": null,
    "text": "quick search"
  },
  "quicksort": {
    "definition": "Pick an element from the array (the pivot), partition the remaining elements into those greater than and less than this pivot, and recursively sort the partitions. There are many variants of the basic scheme above: to select the pivot, to partition the array, to stop the recursion or switch to another algorithm for small partitions, etc.",
    "alsoKnownAs": null,
    "text": "quicksort"
  },
  "radix sort": {
    "definition": "A multiple pass distribution sort algorithm that distributes each item to a bucket according to part of the item's key beginning with the least significant part of the key. After each pass, items are collected from the buckets, keeping the items in order, then redistributed according to the next most significant part of the key.",
    "alsoKnownAs": null,
    "text": "radix sort"
  },
  "ragged matrix": {
    "definition": "A matrix having irregular numbers of items in each row.",
    "alsoKnownAs": null,
    "text": "ragged matrix"
  },
  "random access machine": {
    "definition": "A model of computation whose memory consists of an unbounded sequence of registers, each of which may hold an integer. In this model, arithmetic operations are allowed to compute the address of a memory register.",
    "alsoKnownAs": null,
    "text": "random access machine"
  },
  "randomized algorithm": {
    "definition": "An algorithm that makes random (or pseudorandom) choices.",
    "alsoKnownAs": null,
    "text": "randomized algorithm"
  },
  "randomized binary search tree": {
    "definition": "A binary search tree in which nodes have a randomly assigned priority.  Updates keep priorities in heap order instead of keeping balance information and doing rebalance operations.",
    "alsoKnownAs": "cartesian tree, RBST.",
    "text": "randomized binary search tree"
  },
  "randomized complexity": {
    "definition": "The expected running time of the best possible randomized algorithm over the worst input.",
    "alsoKnownAs": null,
    "text": "randomized complexity"
  },
  "randomized rounding": {
    "definition": "A probabilistic method to convert a solution of a relaxed problem into an approximate solution to the original problem.",
    "alsoKnownAs": null,
    "text": "randomized rounding"
  },
  "random sampling": {
    "definition": "Using a randomly selected sample of the data to help solve a problem on the whole data.",
    "alsoKnownAs": null,
    "text": "random sampling"
  },
  "random search": {
    "definition": "Repeatedly check items in an array at random until successful.",
    "alsoKnownAs": null,
    "text": "random search"
  },
  "range": {
    "definition": "The possible results of a function or relation.  For instance, the range of cosine is [-1,+1].",
    "alsoKnownAs": null,
    "text": "range"
  },
  "range sort": {
    "definition": "A bucket sort where the function to determine the  bucket is based on the range of possible keys.",
    "alsoKnownAs": null,
    "text": "range sort"
  },
  "rank": {
    "definition": "For a given match, this is the number of matches in a longest chain terminating with that match, inclusive.",
    "alsoKnownAs": null,
    "text": "rank"
  },
  "rapid sort": {
    "definition": "A 2-pass sort algorithm that is efficient when the range of keys is approximately equal to the number of items and only keys are sorted. The first pass counts the occurrences of each key in an auxiliary array. The second pass goes over the auxiliary array writing the counted number of keys to the destination.",
    "alsoKnownAs": null,
    "text": "rapid sort"
  },
  "Ratcliff/Obershelp pattern recognition": {
    "definition": "Compute the similarity of two strings as the number of matching characters divided by the total number of characters in the two strings.  Matching characters are those in the longest common substring plus, recursively, matching characters in the unmatched region on either side of the longest common substring.",
    "alsoKnownAs": null,
    "text": "Ratcliff/Obershelp pattern recognition"
  },
  "reachable": {
    "definition": "A vertex v is reachable from another vertex u if there is a path of any length from u to v.",
    "alsoKnownAs": "reachability.",
    "text": "reachable"
  },
  "rebalance": {
    "definition": "Restore balance to a tree.",
    "alsoKnownAs": null,
    "text": "rebalance"
  },
  "recognizer": {
    "definition": "A finite state machine with one or more states designated as accepting states.  An input string is accepted if there is a path from the start state to an accepting state.",
    "alsoKnownAs": null,
    "text": "recognizer"
  },
  "rectangular matrix": {
    "definition": "An n × m matrix, or, one whose size may not be the same in both dimensions.",
    "alsoKnownAs": null,
    "text": "rectangular matrix"
  },
  "rectilinear": {
    "definition": "Distance, paths, lines, etc. which are always parallel to axes at right angles.  For example, a path along the streets of Salt Lake City or the moves of a rook in chess.",
    "alsoKnownAs": null,
    "text": "rectilinear"
  },
  "rectilinear Steiner tree": {
    "definition": "A minimum-length rectilinear tree connecting a set of points, called terminals, in the plane.  This tree may include points other than the terminals, which are called Steiner points.",
    "alsoKnownAs": null,
    "text": "rectilinear Steiner tree"
  },
  "recurrence relation": {
    "definition": "The specification of a sequence of values in terms of earlier values in the sequence and base values.",
    "alsoKnownAs": "recurrence equations.",
    "text": "recurrence relation"
  },
  "recursion": {
    "definition": "An algorithmic technique where a function, in order to accomplish a task, calls itself with some part of the task.",
    "alsoKnownAs": null,
    "text": "recursion"
  },
  "recursion termination": {
    "definition": "The point when conditions are met and a recursive algorithm ceases calling itself and begins to return values.",
    "alsoKnownAs": null,
    "text": "recursion termination"
  },
  "recursion tree": {
    "definition": "A method to analyze the complexity of an algorithm by diagramming the recursive function calls.",
    "alsoKnownAs": null,
    "text": "recursion tree"
  },
  "recursive": {
    "definition": "(1) A data structure that is partially composed of other instances of the data structure.  For instance, a tree is composed of smaller trees (subtrees) and leaf nodes, and a list may  have other lists as elements.  (2) An algorithm in which functions might call themselves.  For instance, quicksort or heapify.",
    "alsoKnownAs": null,
    "text": "recursive"
  },
  "recursive data structure": {
    "definition": "A data structure that is partially composed of smaller or simpler instances of the same data structure.  For instance, a tree is composed of smaller trees (subtrees) and leaf nodes, and a list may have other lists as elements.",
    "alsoKnownAs": null,
    "text": "recursive data structure"
  },
  "recursively enumerable language": {
    "definition": "A language accepted by a Turing machine.",
    "alsoKnownAs": null,
    "text": "recursively enumerable language"
  },
  "red-black tree": {
    "definition": "A nearly-balanced tree that uses an extra bit per  node to maintain balance.  No leaf is more than twice as far from the root as any other.",
    "alsoKnownAs": "symmetric binary B-tree.",
    "text": "red-black tree"
  },
  "reduced basis": {
    "definition": "A basis for a lattice that is nearly orthogonal.",
    "alsoKnownAs": null,
    "text": "reduced basis"
  },
  "reduction": {
    "definition": "A computable transformation of one problem into another.",
    "alsoKnownAs": null,
    "text": "reduction"
  },
  "reflexive": {
    "definition": "A binary relation R for which a R a for all a.",
    "alsoKnownAs": null,
    "text": "reflexive"
  },
  "regular decomposition": {
    "definition": "A space decomposition method that partitions the underlying space by recursively halving it across the various dimensions instead of permitting the partitioning lines to vary.",
    "alsoKnownAs": null,
    "text": "regular decomposition"
  },
  "relation": {
    "definition": "A computation which takes some inputs and yields an output.  Any particular input may yield different outputs at different times. Formally, a mapping from each element in the domain to one or more elements in the range.",
    "alsoKnownAs": null,
    "text": "relation"
  },
  "relational structure": {
    "definition": "The counterpart in formal logic of a data structure or class instance in the object-oriented sense.  Examples are strings, directed graphs, and undirected graphs.  Sets of relational structures generalize the notion of languages as sets of strings.",
    "alsoKnownAs": null,
    "text": "relational structure"
  },
  "relative performance guarantee": {
    "definition": "The maximum ratio by which the result of a ρ-approximation algorithm may depart from the optimal solution.",
    "alsoKnownAs": "performance ratio.",
    "text": "relative performance guarantee"
  },
  "relaxation": {
    "definition": "An optimization problem with an enlarged feasible region (and extended objective function) compared with an original optimization problem.  Typically, the relaxation is considerably easier to solve than the original.",
    "alsoKnownAs": null,
    "text": "relaxation"
  },
  "relaxed balance": {
    "definition": "When rebalancing a search tree is independent of updating the tree.",
    "alsoKnownAs": null,
    "text": "relaxed balance"
  },
  "repeated squaring": {
    "definition": "Compute the nth power of an expression in  Θ(log n) steps by repeatedly squaring an intermediate result and multiplying an accumulating value by the intermediate result when appropriate.",
    "alsoKnownAs": null,
    "text": "repeated squaring"
  },
  "rescalable": {
    "definition": "An optimization for which given any instance of the problem and integer λ >0, there is an easily computed second instance that is the same except that the objective function for the second instance is (element-wise) λ times the objective function of the first instance.  For such problems, the best one can hope for is a relative performance guarantee, not an absolute performance guarantee.",
    "alsoKnownAs": null,
    "text": "rescalable"
  },
  "reservoir sampling": {
    "definition": "Randomly select k items from a stream of items of unknown length.  Save the first k items in an array of size k. For each item j, j > k, choose a random integer M from 1 to j (inclusive).  If M ≤ k, replace item M of the array with item j.",
    "alsoKnownAs": null,
    "text": "reservoir sampling"
  },
  "restricted universe sort": {
    "definition": "A sort algorithm that operates on the basis that the keys are members of a restricted set of values.  They may not require comparisons of keys to perform the sorting.",
    "alsoKnownAs": null,
    "text": "restricted universe sort"
  },
  "R-file": {
    "definition": "A spatial access method which divides space into a hierarchically of nested boxes.  Objects are indexed in the lowest cell which completely contains them.",
    "alsoKnownAs": null,
    "text": "R-file"
  },
  "Rice's method": {
    "definition": "A method of complex asymptotics that can handle certain alternating sums arising in the analysis of algorithms.",
    "alsoKnownAs": null,
    "text": "Rice's method"
  },
  "right rotation": {
    "definition": "(1) In a binary search tree, pushing a node N down and to the right to balance the tree.  N's left child replaces N, and the left child's right child becomes N's left child. (2) In an array, moving all items to the next higher location.  The last item is moved to the first location, which is now vacant. (3) In a list, removing the tail and inserting it at the head.",
    "alsoKnownAs": "rotate right.",
    "text": "right rotation"
  },
  "right-threaded tree": {
    "definition": "A variant of a threaded tree in which only the right thread, i.e. link to the successor, of each node is maintained.",
    "alsoKnownAs": null,
    "text": "right-threaded tree"
  },
  "Robin Hood hashing": {
    "definition": "In case of collision, the item with the longer probe sequence stays in the position.  The other item is moved.  This tends to equalize the length of probe sequences.",
    "alsoKnownAs": null,
    "text": "Robin Hood hashing"
  },
  "root": {
    "definition": "The distinguished initial or fundamental item of a tree. The only item which has no parent. See the figure at tree.",
    "alsoKnownAs": null,
    "text": "root"
  },
  "rooted tree": {
    "definition": "A tree in which one node is designated as the root.",
    "alsoKnownAs": "oriented tree.",
    "text": "rooted tree"
  },
  "rotation": {
    "definition": "To switch children and parents among two or three adjacent nodes to restore balance to a tree.",
    "alsoKnownAs": null,
    "text": "rotation"
  },
  "RP": {
    "definition": "The class of languages for which membership can be determined in polynomial time by a probabilistic Turing machine with no false acceptances and less than half false rejections.  \"RP\" means \"Randomized Polynomial\" time.",
    "alsoKnownAs": "randomized polynomial time.",
    "text": "RP"
  },
  "R+-tree": {
    "definition": "A spatial access method which splits space with hierarchically nested boxes.  Objects are indexed in each box which intersects them.  The tree is height-balanced.",
    "alsoKnownAs": null,
    "text": "R+-tree"
  },
  "R*-tree": {
    "definition": "A spatial access method which splits space in hierarchically nested, possibly overlapping, boxes.  The tree is height-balanced.  It is similar to the R-tree, but reinserts entries upon overflow, rather than splitting.",
    "alsoKnownAs": null,
    "text": "R*-tree"
  },
  "R-tree": {
    "definition": "(1) A spatial access method that splits space with hierarchically nested, and possibly overlapping, boxes.  The tree is height-balanced. (2) A recursion tree.",
    "alsoKnownAs": null,
    "text": "R-tree"
  },
  "run time": {
    "definition": "(1) The amount of time needed to execute an algorithm. (2) The time when a compiled program is executing, versus compile time.",
    "alsoKnownAs": null,
    "text": "run time"
  },
  "saturated edge": {
    "definition": "An edge in a flow network which has the maximum possible flow.",
    "alsoKnownAs": null,
    "text": "saturated edge"
  },
  "SBB tree": {
    "definition": "A symmetric binary B-tree.  Now known as a red-black tree.",
    "alsoKnownAs": null,
    "text": "SBB tree"
  },
  "scan": {
    "definition": "A parallel operation in which each element in an array or linked list receives the sum of all previous elements.",
    "alsoKnownAs": "prefix sums.",
    "text": "scan"
  },
  "scapegoat tree": {
    "definition": "A binary search tree that needs no balance information. Search time is logarithmic, and the amortized cost of update is logarithmic.",
    "alsoKnownAs": null,
    "text": "scapegoat tree"
  },
  "Schorr-Waite graph marking algorithm": {
    "definition": "A class of algorithms to mark all reachable nodes in a directed graph by reversing pointers on the way down, then restoring them upon leaving.  It uses only a few bits of extra space per node and a few work pointers.",
    "alsoKnownAs": null,
    "text": "Schorr-Waite graph marking algorithm"
  },
  "search": {
    "definition": "Look for a value or item in a data structure.  There are dozens of algorithms, data structures, and approaches.",
    "alsoKnownAs": null,
    "text": "search"
  },
  "search tree": {
    "definition": "A tree where every subtree of a node has keys less than any other subtree of the node to its right.  The keys in a node are conceptually between subtrees and are greater than any keys in subtrees to its left and less than any keys in subtrees to its right.",
    "alsoKnownAs": null,
    "text": "search tree"
  },
  "search tree property": {
    "definition": "When the key of every node of a binary tree is larger than the key of its left child and smaller than its right child.",
    "alsoKnownAs": null,
    "text": "search tree property"
  },
  "secant search": {
    "definition": "Search a sorted array by estimating the next position to check based on the values at the two previous positions checked.",
    "alsoKnownAs": null,
    "text": "secant search"
  },
  "secondary clustering": {
    "definition": "The tendency for some collision resolution schemes to create long run of filled slots away from a key hash position, e.g., along the probe sequence.",
    "alsoKnownAs": null,
    "text": "secondary clustering"
  },
  "segment": {
    "definition": "(1) The substring of a pattern delimited by two don't cares or one don't care and beginning or end of the pattern.  (2) A substring.",
    "alsoKnownAs": null,
    "text": "segment"
  },
  "Select": {
    "definition": "A four-part algorithm to select the kth smallest element of an array.  Part 1) Consider the array as groups of 5 elements; sort and find the median of each group.  2) Use Select  recursively to find x, the median of the medians. 3) Next partition the array around x.   4) Let i be the number of elements in the low side of the partition.  If k ≤ i, use Select recursively to find the kth element of the low side.  Otherwise Select the k-ith element of the high side.",
    "alsoKnownAs": null,
    "text": "Select"
  },
  "select and partition": {
    "definition": "Given an array A of n elements and a positive integer k ≤ n, find the kth smallest element of A and partition the array such that A[1], …, A[k-1] ≤ A[k] ≤ A[k+1], …, A[n].",
    "alsoKnownAs": null,
    "text": "select and partition"
  },
  "selection sort": {
    "definition": "A sort algorithm that repeatedly searches remaining items to find the least one and moves it to its final location.  The run time is Θ(n²), where n is the number of elements.  The number of swaps is  O(n).",
    "alsoKnownAs": null,
    "text": "selection sort"
  },
  "select kth element": {
    "definition": "Find the kth smallest element of a set.  Two approaches are a modified distribution sort or  select and partition.",
    "alsoKnownAs": "selection problem, find kth least element, kth smallest element.",
    "text": "select kth element"
  },
  "select mode": {
    "definition": "An algorithm to find the mode, or most frequently occurring value, in a group of elements.",
    "alsoKnownAs": null,
    "text": "select mode"
  },
  "self-loop": {
    "definition": "An edge of a graph which starts and ends at the same vertex.",
    "alsoKnownAs": null,
    "text": "self-loop"
  },
  "self-organizing list": {
    "definition": "A list that reorders the elements based on some self-organizing heuristic [Wikipedia] to improve average access time.",
    "alsoKnownAs": null,
    "text": "self-organizing list"
  },
  "semidefinite programming": {
    "definition": "A generalization of a linear program in which any subset of the variables may be constrained to form a semidefinite matrix.",
    "alsoKnownAs": null,
    "text": "semidefinite programming"
  },
  "separate chaining": {
    "definition": "A scheme in which each position in the hash table has a list to handle collisions.  Each position may be just a link to the list (direct chaining) or may be an item and a link, essentially, the head of a list. In the latter, one item is in the table, and other colliding items are in the list.",
    "alsoKnownAs": "external chaining.",
    "text": "separate chaining"
  },
  "separation theorem": {
    "definition": "A theorem showing that two complexity classes are distinct. Most separation theorems have been proved by diagonalization.",
    "alsoKnownAs": null,
    "text": "separation theorem"
  },
  "set": {
    "definition": "An unordered collection of values where each value occurs at most once. A group of elements with three properties: (1) all elements belong to a universe, (2) either each element is a member of the set or it is not, and (3) the elements are unordered.",
    "alsoKnownAs": null,
    "text": "set"
  },
  "set cover": {
    "definition": "A set of sets whose union has all members of the union of all sets.  The set cover problem is to find a minimum size set.",
    "alsoKnownAs": null,
    "text": "set cover"
  },
  "set packing": {
    "definition": "An optimization problem to find\tthe largest number of mutually disjoint subsets that cover a given set of sets.",
    "alsoKnownAs": null,
    "text": "set packing"
  },
  "shadow heap": {
    "definition": "A heap, implemented in an array, adjacent to an unordered table.  The shadow is the table nodes and all their (recursive) parents, by array index, in the heap.",
    "alsoKnownAs": null,
    "text": "shadow heap"
  },
  "shadow merge": {
    "definition": "An algorithm to merge two heaps by concatenating the smaller heap to the larger, then reordering just the concatenated  nodes and their parents to restore the heap property.",
    "alsoKnownAs": null,
    "text": "shadow merge"
  },
  "shadow merge insert": {
    "definition": "An algorithm to insert a new node into a shadow heap. The new node is placed in the unordered table. When the table grows beyond some threshold size, table  nodes and all their parents are reordered so everything is a heap.",
    "alsoKnownAs": null,
    "text": "shadow merge insert"
  },
  "Shannon-Fano coding": {
    "definition": "A variable-length coding based on the frequency of occurrence of each character.  Divide the characters into two sets with the frequency of each set as close to half as possible, and assign the sets either 0 or 1 coding.  Repeatedly divide the sets until each character has a unique coding.",
    "alsoKnownAs": null,
    "text": "Shannon-Fano coding"
  },
  "shared memory": {
    "definition": "All processors have the same global image of (and access to) all of the memory.",
    "alsoKnownAs": null,
    "text": "shared memory"
  },
  "Shell sort": {
    "definition": "The first diminishing increment sort.  On each pass i sets of n/i items are sorted, typically with insertion sort.  On each succeeding pass, i is reduced until it is 1 for the last pass.  A good series of i values is important to efficiency.",
    "alsoKnownAs": null,
    "text": "Shell sort"
  },
  "Shift-Or": {
    "definition": "A string matching algorithm which keeps an array of bits, R, showing if prefixes of the pattern don't match at the current place.  Before searching, mismatch arrays are computed for each character in the alphabet and saved in an array, S.  For the next position, with the character c, R = shift(R) or S[c].  If the last bit of R is 0, the pattern matches.",
    "alsoKnownAs": null,
    "text": "Shift-Or"
  },
  "shortest common supersequence": {
    "definition": "Find the shortest string that contains two or more strings as subsequences.",
    "alsoKnownAs": null,
    "text": "shortest common supersequence"
  },
  "shortest common superstring": {
    "definition": "Find the shortest string that contains two or more strings as substrings.",
    "alsoKnownAs": null,
    "text": "shortest common superstring"
  },
  "shortest path": {
    "definition": "The problem of finding the shortest path in a graph  from one vertex to another.  \"Shortest\" may be least number of edges, least total weight, etc.",
    "alsoKnownAs": "single-pair shortest-path problem.",
    "text": "shortest path"
  },
  "shuffle sort": {
    "definition": "A distribution sort algorithm that begins by removing the first 1/8 of the n items, sorting them (recursively), and putting them in an array.  This creates n/8 buckets to which the remaining 7/8 of the items are distributed.  Each bucket is then sorted, and the buckets are concatenated.",
    "alsoKnownAs": null,
    "text": "shuffle sort"
  },
  "sibling": {
    "definition": "A node in a tree that has the same parent as another node is its sibling.",
    "alsoKnownAs": null,
    "text": "sibling"
  },
  "sieve of Eratosthenes": {
    "definition": "An algorithm to find all prime numbers up to a certain N. Begin with an (unmarked) array of integers from 2 to N.  The first unmarked integer, 2, is the first prime.  Mark every multiple of this prime.  Repeatedly take the next unmarked integer as the next prime and mark every multiple of the prime.",
    "alsoKnownAs": null,
    "text": "sieve of Eratosthenes"
  },
  "sift up": {
    "definition": "Restoring the heap property by swapping a node with its parent, and repeating the process on the parent until the root is reached or the heap property is satisfied.",
    "alsoKnownAs": null,
    "text": "sift up"
  },
  "signature": {
    "definition": "The types or domains, and order, in some representations, of inputs to and outputs from a function.",
    "alsoKnownAs": null,
    "text": "signature"
  },
  "simple merge": {
    "definition": "Merge n sorted streams into one output stream. All the stream heads are compared, and the head with the least key is removed and written to the output. This is repeated until all streams are empty.",
    "alsoKnownAs": null,
    "text": "simple merge"
  },
  "simple path": {
    "definition": "A path that repeats no vertex, except that the first and last may be the same vertex.",
    "alsoKnownAs": null,
    "text": "simple path"
  },
  "simple uniform hashing": {
    "definition": "The assumption or goal that items are equally likely to hash to any value.",
    "alsoKnownAs": null,
    "text": "simple uniform hashing"
  },
  "simplex": {
    "definition": "The simplest N-dimensional polytope.  The generalization of a triangle (2D) or tetrahedron (3D).",
    "alsoKnownAs": null,
    "text": "simplex"
  },
  "simulated annealing": {
    "definition": "A technique to find a good solution to an optimization problem by trying random variations of the current solution.  A worse variation is accepted as the new solution with a probability that decreases as the computation proceeds.  The slower the cooling schedule, or rate of decrease, the more likely the algorithm is to find an optimal or near-optimal solution.",
    "alsoKnownAs": null,
    "text": "simulated annealing"
  },
  "simulation theorem": {
    "definition": "One kind of computation can be simulated by another kind within stated complexity bounds.  Most known containment or equality relationships between complexity classes were proved this way.",
    "alsoKnownAs": null,
    "text": "simulation theorem"
  },
  "single-destination shortest-path problem": {
    "definition": "Find the shortest path from each vertex in a weighted, directed graph to a specific destination vertex.",
    "alsoKnownAs": null,
    "text": "single-destination shortest-path problem"
  },
  "single program multiple data": {
    "definition": "The dominant style of parallel programming, where all processors use the same program, though each has its own data.",
    "alsoKnownAs": "SPMD.",
    "text": "single program multiple data"
  },
  "single-source shortest-path problem": {
    "definition": "Find the shortest paths from a specific source vertex to every other vertex in a weighted, directed graph.  Dijkstra's algorithm solves this if all weights are nonnegative.  The Bellman-Ford algorithm handles any weights.",
    "alsoKnownAs": null,
    "text": "single-source shortest-path problem"
  },
  "singularity analysis": {
    "definition": "A complex asymptotic technique for determining the asymptotics of certain algebraic functions.",
    "alsoKnownAs": null,
    "text": "singularity analysis"
  },
  "sink": {
    "definition": "A vertex of a directed graph with no outgoing edges.  More formally, a vertex with with out-degree 0.",
    "alsoKnownAs": null,
    "text": "sink"
  },
  "skd-tree": {
    "definition": "The spatial k-d tree is a spatial access method where successive levels are split along different dimensions.  Objects are indexed by their centroid, and the minimum bounding box of objects in a node are stored in the node.",
    "alsoKnownAs": null,
    "text": "skd-tree"
  },
  "skew symmetry": {
    "definition": "The property that the flow is the same amount, but reversed direction, starting from either vertex of every edge of a flow network.  More formally, for an edge e=(v,w), f(v,w) = -f(w,v), where f(a,b) is the flow from a to b.",
    "alsoKnownAs": null,
    "text": "skew symmetry"
  },
  "skip list": {
    "definition": "A randomized variant of an  ordered linked list with additional, parallel lists. Parallel lists at higher levels skip geometrically more items. Searching begins at the highest level, to quickly get to the right part of the list, then uses progressively lower level lists. A new item is added by randomly selecting a level, then inserting it in order in the lists for that and all lower levels.  With enough levels, searching is O(log n).",
    "alsoKnownAs": null,
    "text": "skip list"
  },
  "slope selection": {
    "definition": "Given a set of points in a plane and an integer  k ≤ (   n OVER  2  ), find the line between pairs of points which has the kth smallest slope.",
    "alsoKnownAs": null,
    "text": "slope selection"
  },
  "Smith algorithm": {
    "definition": "A string matching algorithm which computes the shift value for both the rightmost character of the window and the character preceding it, then uses the maximum of the two values.",
    "alsoKnownAs": null,
    "text": "Smith algorithm"
  },
  "Smith-Waterman algorithm": {
    "definition": "A means of searching protein databases to find those with the best alignment.",
    "alsoKnownAs": null,
    "text": "Smith-Waterman algorithm"
  },
  "smoothsort": {
    "definition": "A variant of heapsort that takes advantage of a partially ordered table.  Performance is O(n) when input is sorted and O(n log n)  performance for worst case.",
    "alsoKnownAs": null,
    "text": "smoothsort"
  },
  "solvable": {
    "definition": "A computational problem that can be solved by a Turing machine.  The problem may have a nonbinary output.",
    "alsoKnownAs": null,
    "text": "solvable"
  },
  "sort": {
    "definition": "Arrange items in a predetermined order.  There are dozens of algorithms, the choice of which depends on factors such as the number of items relative to working memory, knowledge of the orderliness of the items or the range of the keys, the cost of comparing keys vs. the cost of moving items, etc.  Most algorithms can be implemented as an in-place sort, and many can be implemented so they are stable, too.",
    "alsoKnownAs": null,
    "text": "sort"
  },
  "sorted array": {
    "definition": "An array whose items are kept sorted, often so searching is faster.",
    "alsoKnownAs": null,
    "text": "sorted array"
  },
  "sorted list": {
    "definition": "A list whose items are kept sorted.",
    "alsoKnownAs": null,
    "text": "sorted list"
  },
  "soundex": {
    "definition": "An algorithm to code surnames phonetically by reducing them to the first letter and up to three digits, where each digit is one of six consonant sounds.  This reduces matching problems from different spellings.",
    "alsoKnownAs": null,
    "text": "soundex"
  },
  "source": {
    "definition": "(1) A vertex of a directed graph with no incoming edges.  More formally, a vertex with in-degree 0. (2) The vertex from which an edge of a directed graph leaves.",
    "alsoKnownAs": null,
    "text": "source"
  },
  "space-constructible function": {
    "definition": "A function s(n) that gives the actual space used by some Turing machine on all inputs of length n.",
    "alsoKnownAs": null,
    "text": "space-constructible function"
  },
  "space ordering method": {
    "definition": "A mapping from a discrete k-dimensional space into a linear order.",
    "alsoKnownAs": null,
    "text": "space ordering method"
  },
  "spanning tree": {
    "definition": "A connected, acyclic subgraph containing all the vertices of a graph.",
    "alsoKnownAs": null,
    "text": "spanning tree"
  },
  "sparse graph": {
    "definition": "A graph in which the number of edges is much less than the possible number of edges.",
    "alsoKnownAs": null,
    "text": "sparse graph"
  },
  "sparse matrix": {
    "definition": "A matrix that has relatively few non-zero (or \"interesting\") entries.  It may be represented in much less than n × m space.",
    "alsoKnownAs": null,
    "text": "sparse matrix"
  },
  "sparsification": {
    "definition": "Technique for designing dynamic graph algorithms, which when applicable transform a time bound of T(n,m) onto O(T(n,n)), where m is the number of edges and n is the number of vertices of the given graph.",
    "alsoKnownAs": null,
    "text": "sparsification"
  },
  "sparsity": {
    "definition": "Instances of the longest common subsequence problem in which the number of matches is small compared to the product of the lengths of the input strings.",
    "alsoKnownAs": null,
    "text": "sparsity"
  },
  "spatial access method": {
    "definition": "A data structure to search for lines, polygons, etc.",
    "alsoKnownAs": "SAM.",
    "text": "spatial access method"
  },
  "spiral storage": {
    "definition": "A dynamic hashing table that grows a few slots at a time.  It uses a hash function, h, with a range of [0,1).  For a key, k, an intermediate value, x=⌈ S-h(k)⌉ +h(k), is computed to find the final slot, ⌊ dx⌋, where d>1 is called the growth factor.  To increase the number of slots, increase S to S' and rehash any keys from  ⌊ dS⌋ to ⌊ dS'⌋-1.",
    "alsoKnownAs": null,
    "text": "spiral storage"
  },
  "splay tree": {
    "definition": "A binary search tree in which operations that access nodes restructure the tree.",
    "alsoKnownAs": null,
    "text": "splay tree"
  },
  "square matrix": {
    "definition": "A n × n matrix, i.e., one whose size is the same in both dimensions.",
    "alsoKnownAs": null,
    "text": "square matrix"
  },
  "square root": {
    "definition": "This describes a \"long hand\" or manual method of calculating or extracting square roots.  Calculation of a square root by hand is a little like long-hand division.",
    "alsoKnownAs": null,
    "text": "square root"
  },
  "SSTable": {
    "definition": "An immutable dictionary stored on disk.  Values are far larger than keys.  Keys and values are in key-order in a \"data block\".   Ordered keys are in an \"index block\", where each key has an offset into its location in the data block.",
    "alsoKnownAs": "sorted-string table.",
    "text": "SSTable"
  },
  "stable": {
    "definition": "An algorithm where the relative order upon input of items with equal keys is always preserved in the output.  Usually a sort algorithm.",
    "alsoKnownAs": null,
    "text": "stable"
  },
  "stack": {
    "definition": "A collection of items in which only the most recently added item may be removed.  The latest added item is at the top.  Basic operations are push and pop.  Often top and isEmpty are available, too. Also known as \"last-in, first-out\" or LIFO.",
    "alsoKnownAs": "LIFO.",
    "text": "stack"
  },
  "stack tree": {
    "definition": "A binary tree where no node, except the root, has more than one non-leaf child.",
    "alsoKnownAs": null,
    "text": "stack tree"
  },
  "star encoding": {
    "definition": "Using a fixed dictionary, encode words in text with strings having many repeated characters, typically an asterisk or \"star\" (*).",
    "alsoKnownAs": null,
    "text": "star encoding"
  },
  "star-shaped polygon": {
    "definition": "A polygon P in which there exists an interior point p such that all the boundary points of P are visible from p.",
    "alsoKnownAs": null,
    "text": "star-shaped polygon"
  },
  "start state": {
    "definition": "An initial state or condition of a finite state machine or Turing machine.  Informally, how the memory is initially set.",
    "alsoKnownAs": null,
    "text": "start state"
  },
  "state": {
    "definition": "The condition of a finite state machine or Turing machine at a certain time.  Informally, the content of memory.",
    "alsoKnownAs": null,
    "text": "state"
  },
  "state machine": {
    "definition": "A model of computation consisting of a (possibly infinite) set of states, a set of start states, an input alphabet, and a transition function which maps input symbols and current states to a next state.  Usually understood to be a finite state machine.",
    "alsoKnownAs": null,
    "text": "state machine"
  },
  "static": {
    "definition": "When the problem domain does not change.",
    "alsoKnownAs": null,
    "text": "static"
  },
  "s-t cut": {
    "definition": "A partitioning of the vertices of a flow network into S and T such that the source is in S and the sink is in T.",
    "alsoKnownAs": null,
    "text": "s-t cut"
  },
  "st-digraph": {
    "definition": "A directed acyclic graph with two specially marked nodes, the source s and the sink t.",
    "alsoKnownAs": null,
    "text": "st-digraph"
  },
  "Steiner point": {
    "definition": "(1) A point that is not part of the input set of points, for instance, a point computed to construct a Steiner tree.  (2) A point with a particular geometric relation to a triangle.",
    "alsoKnownAs": null,
    "text": "Steiner point"
  },
  "Steiner ratio": {
    "definition": "For a given variant of the Steiner tree problem, the maximum possible ratio of the length of a minimum spanning tree of a set of terminals to the length of an optimal Steiner tree of the same set of terminals.  Usually written ρ (rho).",
    "alsoKnownAs": null,
    "text": "Steiner ratio"
  },
  "Steiner tree": {
    "definition": "A minimum-weight tree connecting a designated set of  vertices, called terminals, in an  undirected, weighted graph or points in a space. The tree may include non-terminals, which are called Steiner vertices or Steiner points.",
    "alsoKnownAs": null,
    "text": "Steiner tree"
  },
  "Steiner vertex": {
    "definition": "A point that is not part of the input set of points, for instance, a point computed to construct a Steiner tree.",
    "alsoKnownAs": null,
    "text": "Steiner vertex"
  },
  "Stirling's approximation": {
    "definition": "For large values of n, n! ≈ (n/e)n √(2nπ).",
    "alsoKnownAs": null,
    "text": "Stirling's approximation"
  },
  "Stirling's formula": {
    "definition": "For large values of n, (n/e)n √(2nπ) < n! < (n/e)n(1 + 1/(12n-1)) √(2nπ).",
    "alsoKnownAs": null,
    "text": "Stirling's formula"
  },
  "stooge sort": {
    "definition": "A terribly inefficient sort algorithm that swaps the top and bottom items if needed, then (recursively) sorts the bottom two-thirds, then the top two-thirds, then the bottom two-thirds again.",
    "alsoKnownAs": null,
    "text": "stooge sort"
  },
  "straight-line drawing": {
    "definition": "A graph drawing in which each edge is represented by a straight line segment.",
    "alsoKnownAs": null,
    "text": "straight-line drawing"
  },
  "strand sort": {
    "definition": "A sort algorithm that works well if many items are in order. First, begin a sublist by moving the first item from the original list to the sublist.  For each subsequent item in the original list, if it is greater than the last item of the sublist, remove it from the original list and append it to the sublist. Merge the sublist into a final, sorted list.  Repeatedly extract and merge  sublists until all items are sorted.  Handle two or fewer items as special cases.",
    "alsoKnownAs": null,
    "text": "strand sort"
  },
  "strictly decreasing": {
    "definition": "A function from a partially ordered domain to a partially ordered range such that x < y implies f(x) > f(y).",
    "alsoKnownAs": null,
    "text": "strictly decreasing"
  },
  "strictly increasing": {
    "definition": "A function from a partially ordered domain to a partially ordered range such that x < y implies f(x) < f(y).",
    "alsoKnownAs": null,
    "text": "strictly increasing"
  },
  "strictly lower triangular matrix": {
    "definition": "A matrix that is only defined at (i,j) when i > j.",
    "alsoKnownAs": null,
    "text": "strictly lower triangular matrix"
  },
  "strictly upper triangular matrix": {
    "definition": "A matrix that is only defined at (i,j) when i < j.",
    "alsoKnownAs": null,
    "text": "strictly upper triangular matrix"
  },
  "string": {
    "definition": "A list of characters, usually implemented as an array. Informally a word, phrase, sentence, etc. Since text processing is so common, a special type with substring operations is often available.",
    "alsoKnownAs": null,
    "text": "string"
  },
  "string editing problem": {
    "definition": "The problem of finding an edit script of minimum cost which transforms a given string into another given string.",
    "alsoKnownAs": null,
    "text": "string editing problem"
  },
  "string matching": {
    "definition": "The problem of finding occurrence(s) of a pattern string  within another string or body of text.  There are many different algorithms for efficient searching.",
    "alsoKnownAs": "exact string matching, string searching, text searching.",
    "text": "string matching"
  },
  "string matching with errors": {
    "definition": "Searching for approximate (e.g., up to a predefined number of symbol mismatches, insertions, and deletions) occurrences of a pattern string in a text string.  Preprocessing, e.g., building an index, may or may not be allowed.",
    "alsoKnownAs": "approximate string matching.",
    "text": "string matching with errors"
  },
  "string matching with mismatches": {
    "definition": "The special case of string matching with errors where mismatches are the only type of error allowed.",
    "alsoKnownAs": null,
    "text": "string matching with mismatches"
  },
  "strip packing": {
    "definition": "Pack a set of rectangles into a strip of width 1 to minimize the height used.  Rectangles may not overlap or be rotated.  Without loss of generality, the height of rectangles is at most 1.  This is NP-hard.",
    "alsoKnownAs": null,
    "text": "strip packing"
  },
  "strongly connected component": {
    "definition": "A strongly connected subgraph, S, of a directed graph, D, such that no vertex of D can be added to S and it still be strongly connected.  Informally, a maximal subgraph in which every vertex is reachable from every other vertex.",
    "alsoKnownAs": null,
    "text": "strongly connected component"
  },
  "strongly connected graph": {
    "definition": "A directed graph that has a path from each vertex to every other vertex.",
    "alsoKnownAs": null,
    "text": "strongly connected graph"
  },
  "strongly NP-hard": {
    "definition": "The complexity class of decision problems which are still NP-hard even when all numbers in the input are bounded by some polynomial in the length of the input.",
    "alsoKnownAs": null,
    "text": "strongly NP-hard"
  },
  "strsrch": {
    "definition": "Find occurrences of a substring in a target string by trying the substring at each possible location in the string.  Execution time is Θ(mn), where m is length of the target string and n is the length of the substring.",
    "alsoKnownAs": null,
    "text": "strsrch"
  },
  "stupid sort": {
    "definition": "(1) The original name of gnome sort. (2) An alternate name for bogosort.",
    "alsoKnownAs": null,
    "text": "stupid sort"
  },
  "subadditive ergodic theorem": {
    "definition": "If a stationary and ergodic process satisfies the subadditive inequality, it grows almost surely linearly in time.",
    "alsoKnownAs": null,
    "text": "subadditive ergodic theorem"
  },
  "subgraph": {
    "definition": "A graph whose vertices and edges are subsets of another graph.",
    "alsoKnownAs": null,
    "text": "subgraph"
  },
  "subgraph isomorphism": {
    "definition": "Decide if there is a subgraph of one graph which is  isomorphic to another graph.",
    "alsoKnownAs": null,
    "text": "subgraph isomorphism"
  },
  "sublinear time algorithm": {
    "definition": "A algorithm whose execution time, f(n), grows slower than the size of the problem, n, but only gives an approximate or probably correct answer.",
    "alsoKnownAs": null,
    "text": "sublinear time algorithm"
  },
  "subsequence": {
    "definition": "Any string that can be obtained by deleting zero or more symbols from a given string.",
    "alsoKnownAs": null,
    "text": "subsequence"
  },
  "subset": {
    "definition": "A set S1 is a subset of another set S2 if every element in S1 is in S2.  S2 may have exactly the same elements as S1.",
    "alsoKnownAs": null,
    "text": "subset"
  },
  "substring": {
    "definition": "A string v is a substring of a string u if u=u′ vu″  for some prefix u′ and suffix u″.",
    "alsoKnownAs": "factor.",
    "text": "substring"
  },
  "subtree": {
    "definition": "The tree which is a child of a node.",
    "alsoKnownAs": null,
    "text": "subtree"
  },
  "suffix": {
    "definition": "The end characters of a string.  More formally a string v is a suffix of a string u if u=u'v for some string u'.",
    "alsoKnownAs": null,
    "text": "suffix"
  },
  "suffix array": {
    "definition": "An array of all starting positions of suffixes of a string arranged in lexicographical order. This allows a binary search or fast substring search.",
    "alsoKnownAs": null,
    "text": "suffix array"
  },
  "suffix automaton": {
    "definition": "The smallest automaton accepting all suffixes of a string.  The states form a directed acyclic word graph or DAWG.",
    "alsoKnownAs": null,
    "text": "suffix automaton"
  },
  "suffix tree": {
    "definition": "A compact representation of a trie corresponding to the suffixes of a given string where all nodes with one child are merged with their parents.",
    "alsoKnownAs": null,
    "text": "suffix tree"
  },
  "superimposed code": {
    "definition": "A set of bit vectors such that no vector is a subset of a bitwise or of a small number of others.",
    "alsoKnownAs": null,
    "text": "superimposed code"
  },
  "superset": {
    "definition": "A set S1 is a superset of another set S2 if every element in S2 is in S1.  S1 may have elements which are not in S2.",
    "alsoKnownAs": null,
    "text": "superset"
  },
  "supersink": {
    "definition": "A vertex of a directed graph which is reachable from all other vertices.",
    "alsoKnownAs": null,
    "text": "supersink"
  },
  "supersource": {
    "definition": "A vertex of a directed graph from which all other vertices are reachable.",
    "alsoKnownAs": null,
    "text": "supersource"
  },
  "symmetric": {
    "definition": "A binary relation R for which a R b implies b R a.",
    "alsoKnownAs": null,
    "text": "symmetric"
  },
  "symmetric set difference": {
    "definition": "Members which are in either set, but not in both.  That is, for sets A and B, it is (A - B) ∪ (B - A).",
    "alsoKnownAs": null,
    "text": "symmetric set difference"
  },
  "symmetry breaking": {
    "definition": "To differentiate parts of a structure, such as a graph, which locally look the same to all vertices.  Usually implemented with randomization.",
    "alsoKnownAs": null,
    "text": "symmetry breaking"
  },
  "tabulation hashing": {
    "definition": "The hash value is the xor of values from tables (arrays) indexed by characters.",
    "alsoKnownAs": null,
    "text": "tabulation hashing"
  },
  "taco sort": {
    "definition": "A terribly inefficient sort algorithm that repeatedly changes a random item by a random amount until a sorted permutation occurs. For an array of n elements of k bits each, the expected run time is n × 2nk.",
    "alsoKnownAs": null,
    "text": "taco sort"
  },
  "tail": {
    "definition": "(1) The last item of a list. (2) All but the first item of a list; the list following the head.",
    "alsoKnownAs": null,
    "text": "tail"
  },
  "tail recursion": {
    "definition": "A special form of recursion where the last operation of a function is a recursive call.  The recursion may be optimized away by executing the call in the current stack frame and returning its result rather than creating a new stack frame.",
    "alsoKnownAs": null,
    "text": "tail recursion"
  },
  "target": {
    "definition": "The vertex which an edge of a directed graph enters.",
    "alsoKnownAs": null,
    "text": "target"
  },
  "temporal logic": {
    "definition": "A logic with a notion of time included.  The formulas can express facts about past, present, and future states.  The formulas are interpreted over Kripke structures, which can model computation; hence temporal logic is very useful in formal verification.",
    "alsoKnownAs": null,
    "text": "temporal logic"
  },
  "terminal": {
    "definition": "The set of points in a plane or vertices in a  graph defining endpoints of a Steiner tree.",
    "alsoKnownAs": null,
    "text": "terminal"
  },
  "ternary search tree": {
    "definition": "A 3-way tree where every node's left  subtree has keys less than the node's key, every middle subtree has keys equal to the node's key, and every right subtree has keys greater than the node's key.  If the key is a multikey (string, array, list, etc.), the middle subtree organizes by the next subkey (character, array or list item, etc.)",
    "alsoKnownAs": "TST.",
    "text": "ternary search tree"
  },
  "text": {
    "definition": "A list of characters, usually thought of as a list of words separated by spaces.",
    "alsoKnownAs": null,
    "text": "text"
  },
  "threaded tree": {
    "definition": "A binary search tree in which each node uses an otherwise-empty left child link to refer to the node's in-order predecessor and an empty right child link to refer to its in-order successor.",
    "alsoKnownAs": null,
    "text": "threaded tree"
  },
  "three-dimensional": {
    "definition": "Dealing with or restricted to a space in which location can be completely described with exactly three orthogonal axes.",
    "alsoKnownAs": null,
    "text": "three-dimensional"
  },
  "three-way merge sort": {
    "definition": "A k-way merge sort which uses three input and three output streams.",
    "alsoKnownAs": null,
    "text": "three-way merge sort"
  },
  "time-constructible function": {
    "definition": "A function t(n) that gives the actual running time of some Turing machine on all inputs of length n.",
    "alsoKnownAs": null,
    "text": "time-constructible function"
  },
  "time/space complexity": {
    "definition": "The maximum time or space required by a Turing machine on any input of length n.",
    "alsoKnownAs": null,
    "text": "time/space complexity"
  },
  "top-down radix sort": {
    "definition": "A recursive bucket sort where elements are distributed based on succeeding pieces (characters) of the key.",
    "alsoKnownAs": null,
    "text": "top-down radix sort"
  },
  "topological order": {
    "definition": "A numbering of the vertices of a directed acyclic graph such that every edge from a vertex numbered i to a vertex numbered j satisfies i<j.",
    "alsoKnownAs": null,
    "text": "topological order"
  },
  "topological sort": {
    "definition": "To arrange items when some pairs of items have no comparison, that is, according to a partial order.",
    "alsoKnownAs": null,
    "text": "topological sort"
  },
  "topology tree": {
    "definition": "Tree that describes a balanced decomposition of another tree, according to its topology.  More precisely, given a restricted multilevel partition for a tree T, a topology tree satisfies the following: (1) A topology tree node at level l represents a vertex cluster at level l in the restricted multilevel partition, and (2) A node at level l ≥ 1 has at most two children, representing the vertex clusters at level l-1 whose union gives the vertex cluster the node represents.",
    "alsoKnownAs": null,
    "text": "topology tree"
  },
  "total function": {
    "definition": "A function which is defined for all inputs of the right type, that is, for all of a domain.",
    "alsoKnownAs": null,
    "text": "total function"
  },
  "totally undecidable problem": {
    "definition": "A problem that cannot be solved by a Turing machine.",
    "alsoKnownAs": null,
    "text": "totally undecidable problem"
  },
  "total order": {
    "definition": "An order defined for all pairs of items of a set.  For instance, ≤ (less than or equal to) is a total order on integers, that is, for any two integers, one of them is less than or equal to the other.",
    "alsoKnownAs": "linear order.",
    "text": "total order"
  },
  "tournament": {
    "definition": "Find the maximum of a set of n elements in  ⌈log n⌉ \"rounds\" (passes) by \"playing\" (comparing) pairs of elements and advancing the winner (greater) of each pair to the next round.  It takes n-1 comparisons, like linear search, but may be parallelized, extended to also find the second greatest element, etc.",
    "alsoKnownAs": null,
    "text": "tournament"
  },
  "towers of Hanoi": {
    "definition": "Given three posts (towers) and n disks of decreasing sizes, move the disks from one post to another one at a time without putting a larger disk on a smaller one.  The minimum is 2n-1 moves.  The \"ancient legend\" was invented by De Parville in 1884.",
    "alsoKnownAs": null,
    "text": "towers of Hanoi"
  },
  "tractable": {
    "definition": "A problem which has an algorithm which computes all instances of it in polynomial time.",
    "alsoKnownAs": null,
    "text": "tractable"
  },
  "transition": {
    "definition": "The change from one state to another in a finite state machine.  Analogously, an edge in a directed graph.",
    "alsoKnownAs": "state transition, move.",
    "text": "transition"
  },
  "transition function": {
    "definition": "A function of the current state and input giving the next state of a finite state machine or Turing machine.",
    "alsoKnownAs": null,
    "text": "transition function"
  },
  "transitive": {
    "definition": "A binary relation R for which a R b and b R c implies a R c.",
    "alsoKnownAs": null,
    "text": "transitive"
  },
  "transitive closure": {
    "definition": "An extension or superset of a binary relation such that whenever (a,b) and (b,c) are in the extension, (a,c) is also in the extension.",
    "alsoKnownAs": null,
    "text": "transitive closure"
  },
  "transitive reduction": {
    "definition": "The transitive reduction of a directed graph G is the directed graph G' with the smallest number of edges such that for every path between vertices in G, G' has a path between those vertices.",
    "alsoKnownAs": null,
    "text": "transitive reduction"
  },
  "transpose sequential search": {
    "definition": "Search an array or list by checking items one at a time.  If the value is found, swap it with its predecessor so it is found faster next time.",
    "alsoKnownAs": "self-organizing sequential search.",
    "text": "transpose sequential search"
  },
  "traveling salesman": {
    "definition": "Find a path through a weighted graph that starts and ends at the same vertex, includes every other vertex exactly once, and minimizes the total cost of edges.",
    "alsoKnownAs": "TSP.",
    "text": "traveling salesman"
  },
  "treap": {
    "definition": "A binary search tree in which nodes have another key, called the priority.  Operations also keep the nodes heap ordered with regard to the priority.",
    "alsoKnownAs": null,
    "text": "treap"
  },
  "tree": {
    "definition": "(1) A data structure accessed beginning at the root node.  Each node is either a leaf or an internal node.  An internal node has one or more child nodes and is called the parent of its child nodes.  All children of the same node are siblings. Contrary to a physical tree, the root is usually depicted at the top of the structure, and the leaves are depicted at the bottom. (2) A connected, undirected, acyclic graph.  It is rooted and ordered unless otherwise specified.    Thanks to Joshua O'Madadhain (jmadden@ics.uci.edu) for the figure, 6 October 2005.",
    "alsoKnownAs": null,
    "text": "tree"
  },
  "tree automaton": {
    "definition": "An extension of a finite state machine that operates on n-ary constructors.  Where a finite state automaton reaches a new state with a single state and character, a tree automaton takes n states and constructors.  Tree automata may be top-down (starting from the root) or bottom-up (starting from the leaves), and deterministic or nondeterministic.",
    "alsoKnownAs": null,
    "text": "tree automaton"
  },
  "tree contraction": {
    "definition": "Contracting a tree by removing some of the nodes.",
    "alsoKnownAs": null,
    "text": "tree contraction"
  },
  "tree editing problem": {
    "definition": "The problem of finding an edit script of minimum cost which transforms a given tree into another given tree.",
    "alsoKnownAs": null,
    "text": "tree editing problem"
  },
  "treesort (1)": {
    "definition": "A sort algorithm that first builds a binary search tree of the keys, then accesses the keys with an in-order traversal.",
    "alsoKnownAs": null,
    "text": "treesort (1)"
  },
  "treesort (2)": {
    "definition": "Variants of heapsort.",
    "alsoKnownAs": null,
    "text": "treesort (2)"
  },
  "tree traversal": {
    "definition": "A technique for processing the nodes of a tree in some order.",
    "alsoKnownAs": null,
    "text": "tree traversal"
  },
  "triangle inequality": {
    "definition": "The property that a complete weighted graph satisfies  weight(u,v) ≤  weight(u,w) + weight(w,v) for all vertices u, v, w. Informally, the graph has no short cuts.",
    "alsoKnownAs": null,
    "text": "triangle inequality"
  },
  "triconnected graph": {
    "definition": "A connected graph such that deleting any two vertices (and incident edges) results in a graph that is still connected.",
    "alsoKnownAs": null,
    "text": "triconnected graph"
  },
  "trie": {
    "definition": "A tree for storing strings in which there is one node for every common prefix.  The strings are stored in extra leaf nodes.",
    "alsoKnownAs": null,
    "text": "trie"
  },
  "trinary function": {
    "definition": "A function with three arguments.",
    "alsoKnownAs": null,
    "text": "trinary function"
  },
  "tripartition": {
    "definition": "To partition array elements into three groups.",
    "alsoKnownAs": null,
    "text": "tripartition"
  },
  "Turing machine": {
    "definition": "A model of computation consisting of a finite state machine controller, a read-write head, and an unbounded sequential tape. Depending on the current state and symbol read on the tape, the machine can change its state and move the head to the left or right. Unless otherwise specified, a Turing machine is deterministic.",
    "alsoKnownAs": null,
    "text": "Turing machine"
  },
  "Turing reduction": {
    "definition": "A reduction computable by an oracle Turing machine that halts for all inputs.",
    "alsoKnownAs": null,
    "text": "Turing reduction"
  },
  "twin grid file": {
    "definition": "A point access method which is two simultaneous  grid files.  Points are shuffled between the primary and secondary file to minimize the total size.",
    "alsoKnownAs": null,
    "text": "twin grid file"
  },
  "twisted tabulation hashing": {
    "definition": "Similar to tabulation hashing, except that the last table is indexed by the xor of the last character and a twister value from the rest of the string.",
    "alsoKnownAs": null,
    "text": "twisted tabulation hashing"
  },
  "2-choice hashing": {
    "definition": "A variant of a hash table in which keys are added by hashing with two hash functions.  The key is put in the array position with the fewer (colliding) keys.   Some collision resolution scheme is needed, unless keys are kept in buckets.  The average-case cost of a successful search is O(2 + (m-1)/n), where m is the number of keys and n is the size of the array. The most collisions is log2 ln n + Θ(m/n) with high probability.",
    "alsoKnownAs": null,
    "text": "2-choice hashing"
  },
  "two-dimensional": {
    "definition": "Dealing with or restricted to a plane.  An organization where location can be completely described with exactly two orthogonal axes.",
    "alsoKnownAs": null,
    "text": "two-dimensional"
  },
  "2-left hashing": {
    "definition": "A dictionary implemented with two hash tables of equal size, T1 and T2, and two different hash functions, h1 and h2. A new key is put in table 2 only if there are fewer (colliding) keys at T2[h2(key)] than at T1[h1(key)], otherwise it is put in table 1. With n keys and two tables of size n/2, the most collisions is 0.69... log2 ln n +  O(1) with high probability.",
    "alsoKnownAs": null,
    "text": "2-left hashing"
  },
  "two-level grid file": {
    "definition": "A point access method which is two levels of  grid files.  The first level addresses second level grid files.",
    "alsoKnownAs": null,
    "text": "two-level grid file"
  },
  "2-3-4 tree": {
    "definition": "A B-tree of order 4, that is, internal nodes have two, three, or four children.",
    "alsoKnownAs": null,
    "text": "2-3-4 tree"
  },
  "2-3 tree": {
    "definition": "A B-tree of order 3, that is, internal nodes have two or three children.",
    "alsoKnownAs": null,
    "text": "2-3 tree"
  },
  "Two Way algorithm": {
    "definition": "Partition (\"factor\") the pattern, x, into left, xl, and right, xr, parts in such a way to optimize searching.  Compare xr left to right then, if it matches, compare xl right to left.",
    "alsoKnownAs": null,
    "text": "Two Way algorithm"
  },
  "two-way merge sort": {
    "definition": "A k-way merge sort that sorts a data stream using repeated merges.  It distributes the input into two streams by repeatedly reading a block of input that fits in memory, a run, sorting it, then writing it to the next stream.  It merges runs from the two streams into an output stream.  It then repeatedly distributes the runs in the output stream to the two streams and merges them until there is a single sorted output.",
    "alsoKnownAs": null,
    "text": "two-way merge sort"
  },
  "UB-tree": {
    "definition": "Refers to either universal B-tree or unlimited branching tree.",
    "alsoKnownAs": null,
    "text": "UB-tree"
  },
  "unary function": {
    "definition": "A function which takes one argument.",
    "alsoKnownAs": null,
    "text": "unary function"
  },
  "unbiased coin flipping algorithm": {
    "definition": "To get unbiased random bits, flip a coin twice.  If it comes up heads then tails, the result bit is 1.  It it comes up tails then heads, the result is 0. Repeat the double flips until one of these occurs.",
    "alsoKnownAs": null,
    "text": "unbiased coin flipping algorithm"
  },
  "unbounded knapsack problem": {
    "definition": "Given types of items of different values and volumes, find the most valuable set of items that fit in a knapsack of fixed volume. The number of items of each type is unbounded.  This is an NP-hard  combinatorial optimization problem.",
    "alsoKnownAs": "UKP.",
    "text": "unbounded knapsack problem"
  },
  "uncomputable function": {
    "definition": "A function that cannot be computed by any algorithm --- equivalently, not by any Turing machine.",
    "alsoKnownAs": null,
    "text": "uncomputable function"
  },
  "undecidable language": {
    "definition": "A language for which the membership cannot be decided by an algorithm --- equivalently, cannot be recognized by a Turing machine that halts for all inputs.",
    "alsoKnownAs": null,
    "text": "undecidable language"
  },
  "undecidable problem": {
    "definition": "A problem that cannot be solved for all cases by any algorithm whatsoever---equivalently, whose associated language cannot be recognized by a Turing machine that halts for all inputs.",
    "alsoKnownAs": null,
    "text": "undecidable problem"
  },
  "undirected graph": {
    "definition": "A graph whose edges are unordered pairs of  vertices.  That is, each edge connects two vertices.",
    "alsoKnownAs": null,
    "text": "undirected graph"
  },
  "uniform circuit complexity": {
    "definition": "The study of complexity classes defined by uniform circuit families.",
    "alsoKnownAs": null,
    "text": "uniform circuit complexity"
  },
  "uniform circuit family": {
    "definition": "A sequence of circuits, one for each input length n, that can be efficiently generated by a Turing machine.",
    "alsoKnownAs": null,
    "text": "uniform circuit family"
  },
  "uniform hashing": {
    "definition": "A conceptual method of open addressing for a hash table. A collision is resolved by putting the item in the next empty place given by a probe sequence which is independent of sequences for all other key.",
    "alsoKnownAs": null,
    "text": "uniform hashing"
  },
  "uniform matrix": {
    "definition": "A matrix having the same number of items in each row.",
    "alsoKnownAs": null,
    "text": "uniform matrix"
  },
  "union": {
    "definition": "The union of two sets is a set having all members in either set.",
    "alsoKnownAs": null,
    "text": "union"
  },
  "union of automata": {
    "definition": "Find an automaton that accepts everything which the automata accept individually.",
    "alsoKnownAs": null,
    "text": "union of automata"
  },
  "universal hashing": {
    "definition": "A scheme that chooses randomly from a set of hash functions.",
    "alsoKnownAs": null,
    "text": "universal hashing"
  },
  "universal state": {
    "definition": "A state in an alternating Turing machine from which the machine accepts only if all possible moves lead to acceptance.",
    "alsoKnownAs": null,
    "text": "universal state"
  },
  "universal Turing machine": {
    "definition": "A Turing machine that is capable of simulating any other Turing machine by encoding the latter.",
    "alsoKnownAs": null,
    "text": "universal Turing machine"
  },
  "universe": {
    "definition": "All potential elements of a set.",
    "alsoKnownAs": null,
    "text": "universe"
  },
  "unlimited branching tree": {
    "definition": "A forest of ordered trees used to contain ordered lists.  The root of each tree is unique.  An ordered list is represented by a traversal from the root (first element of the list) to a leaf (last list element).  Lists with common prefixes share nodes.  The last node in common has one child for each list. This allows rapid searches for subset inclusion of sequences.",
    "alsoKnownAs": null,
    "text": "unlimited branching tree"
  },
  "unranking": {
    "definition": "Given a ranking, r, generate the rth permutation of n elements.",
    "alsoKnownAs": null,
    "text": "unranking"
  },
  "UnShuffle sort": {
    "definition": "A distribution sort with two phases.  In the first phase, the inputs are distributed among doubly-ended queues keeping the items in each queue ordered and creating a new queue when there is no place on an existing queue.  The second phase is an  ideal merge in which the item to be removed is determined by keeping the queues in a priority queue.",
    "alsoKnownAs": null,
    "text": "UnShuffle sort"
  },
  "unsolvable problem": {
    "definition": "A computational problem that cannot be solved by a Turing machine.  The associated function is called an uncomputable function.",
    "alsoKnownAs": null,
    "text": "unsolvable problem"
  },
  "unsorted list": {
    "definition": "A list whose order of items, if any, is not known.",
    "alsoKnownAs": null,
    "text": "unsorted list"
  },
  "upper triangular matrix": {
    "definition": "A matrix that is only defined at (i,j) when i ≤ j.",
    "alsoKnownAs": null,
    "text": "upper triangular matrix"
  },
  "van Emde-Boas priority queue": {
    "definition": "An efficient implementation of priority queues where insert, delete, get minimum, get maximum, etc. take  O(log log N) time, where N is the total possible number of keys.  Depending on the circumstance, the implementation is null (if the queue is empty), an integer (if the queue has one integer), a bit vector of size N (if N is small), or a special data structure: an array of priority queues, called the bottom queues, and one more priority queue of array indexes of the bottom queues.",
    "alsoKnownAs": null,
    "text": "van Emde-Boas priority queue"
  },
  "vehicle routing problem": {
    "definition": "Find an optimal route of one or more vehicles through a graph.",
    "alsoKnownAs": "VRP.",
    "text": "vehicle routing problem"
  },
  "Venn diagram": {
    "definition": "A visual depiction of membership in sets according to binary properties, using overlapping ovals to divide the plane into regions.  Regions inside an oval have the property the oval represents, while regions outside it do not have the property. Regions are shaded to show combinations of properties (or sets) of interest, or elements are placed in regions corresponding to their properties (or membership).",
    "alsoKnownAs": null,
    "text": "Venn diagram"
  },
  "vertex": {
    "definition": "An item in a graph.  Sometimes referred to as a node.",
    "alsoKnownAs": null,
    "text": "vertex"
  },
  "vertex coloring": {
    "definition": "An assignment of colors (or any distinct marks) to the  vertices of a graph.  Strictly speaking, a coloring is  proper if no two adjacent vertices have the same color.",
    "alsoKnownAs": null,
    "text": "vertex coloring"
  },
  "vertex connectivity": {
    "definition": "(1) The smallest number of vertices whose deletion causes a connected graph to not be connected.  (2) For a pair of vertices s and t in a graph, the smallest number of vertices whose deletion will separate s from t.",
    "alsoKnownAs": null,
    "text": "vertex connectivity"
  },
  "vertex cover": {
    "definition": "A set of vertices in an undirected graph where every edge connects at least one vertex.  The vertex cover problem is to find a minimum size set and is NP-complete.",
    "alsoKnownAs": null,
    "text": "vertex cover"
  },
  "vertical visibility map": {
    "definition": "A partition of the plane into regions by drawing a vertical straight line through each vertex p of a planar straight-line graph until it intersects an edge e of the graph or extends to infinity.  The edge e is said to be vertically visible from p.",
    "alsoKnownAs": null,
    "text": "vertical visibility map"
  },
  "visibility map": {
    "definition": "A planar subdivision that encodes the visibility information, that is, which points are mutually visible.",
    "alsoKnownAs": null,
    "text": "visibility map"
  },
  "visible": {
    "definition": "Two points p and q are visible if the straight line segment between them does not intersect any other object, edge, etc.",
    "alsoKnownAs": null,
    "text": "visible"
  },
  "Viterbi algorithm": {
    "definition": "An algorithm to compute the optimal (most likely) state sequence in a hidden Markov model given a sequence of observed outputs.",
    "alsoKnownAs": null,
    "text": "Viterbi algorithm"
  },
  "Vitter's algorithm": {
    "definition": "An adaptive Huffman coding scheme.  Typically this produces codings the same length as or shorter than static Huffman coding. In the worst case, this uses one more bit per codeword.",
    "alsoKnownAs": null,
    "text": "Vitter's algorithm"
  },
  "walk": {
    "definition": "A path in which edges may be repeated.",
    "alsoKnownAs": null,
    "text": "walk"
  },
  "weak-heap": {
    "definition": "A relaxed heap satisfying the following three conditions: (1) every key in the right subtree of a node is greater      than the key stored in the node itself,  (2) the root has no left child, and (3) leaves are only found on the last two levels of the tree.",
    "alsoKnownAs": null,
    "text": "weak-heap"
  },
  "weak-heap sort": {
    "definition": "A sort algorithm that builds a weak-heap, then repeatedly extracts the maximum item.  In the worst case, the run time is O(n log n + 0.1 n).",
    "alsoKnownAs": null,
    "text": "weak-heap sort"
  },
  "weighted, directed graph": {
    "definition": "A directed graph that has a weight, or numeric value, associated with each edge.",
    "alsoKnownAs": null,
    "text": "weighted, directed graph"
  },
  "weighted graph": {
    "definition": "A graph having a weight, or number, associated with each edge.  Some algorithms require all weights to be nonnegative, integral, positive, etc.",
    "alsoKnownAs": "edge-weighted graph.",
    "text": "weighted graph"
  },
  "window": {
    "definition": "substring of the text that is aligned with the pattern.",
    "alsoKnownAs": null,
    "text": "window"
  },
  "witness": {
    "definition": "(1) a structure providing an easily verified bound on the optimal value of an optimization problem.  Typically used in the analysis of an approximation algorithm to prove the performance guarantee. (2) a mismatch of two symbols of string y at a distance of d is a \"witness\" to the fact that in no subject y could occur twice at a distance of exactly d positions (equivalently, that d cannot be a period of y).",
    "alsoKnownAs": null,
    "text": "witness"
  },
  "work": {
    "definition": "The total number of operations taken by a computation.",
    "alsoKnownAs": null,
    "text": "work"
  },
  "work-depth model": {
    "definition": "A model of parallel computation in which one keeps track of the total work and depth of a computation without worrying about how it maps onto a machine.",
    "alsoKnownAs": null,
    "text": "work-depth model"
  },
  "work-efficient": {
    "definition": "A parallel algorithm which asymptotically requires at most a constant factor more work than the best known sequential algorithm or the optimal work.",
    "alsoKnownAs": null,
    "text": "work-efficient"
  },
  "work-preserving": {
    "definition": "A translation of an algorithm from one model of computation to another in which the work is the same in both models, to within a constant factor.",
    "alsoKnownAs": null,
    "text": "work-preserving"
  },
  "worst case": {
    "definition": "(1) The situation or input that forces an algorithm or data structure to take the most time or resources. (2) Having to do with this situation or input.",
    "alsoKnownAs": null,
    "text": "worst case"
  },
  "worst-case cost": {
    "definition": "The highest possible use of resources of an algorithm, which occurs for the most pessimistic, or worst possible, input.",
    "alsoKnownAs": null,
    "text": "worst-case cost"
  },
  "worst-case execution time": {
    "definition": "The execution time of an algorithm in the worst case.",
    "alsoKnownAs": "WCET.",
    "text": "worst-case execution time"
  },
  "worst-case minimum access": {
    "definition": "A figure of merit for a family of searches, the \"best\" is the search that takes the minimum accesses in the worst case.",
    "alsoKnownAs": null,
    "text": "worst-case minimum access"
  },
  "xor": {
    "definition": "\"Exclusive OR\" or \"not equal to\" function:  0 XOR 0 = 0, 0 XOR 1 = 1, 1 XOR 0 = 1, 1 XOR 1 = 0.",
    "alsoKnownAs": "exclusive or.",
    "text": "xor"
  },
  "Zeller's congruence": {
    "definition": "An algorithm to find the day of the week for any date.",
    "alsoKnownAs": null,
    "text": "Zeller's congruence"
  },
  "0-ary function": {
    "definition": "A function that takes no arguments.",
    "alsoKnownAs": "nullary function.",
    "text": "0-ary function"
  },
  "0-based indexing": {
    "definition": "Indexing (an array) beginning with 0.",
    "alsoKnownAs": null,
    "text": "0-based indexing"
  },
  "Zhu-Takaoka": {
    "definition": "A string matching algorithm that is a variant of the Boyer-Moore algorithm.  It uses two consecutive text characters to compute the bad character shift.  It is faster when the alphabet or pattern is small, but the skip table grows quickly, slowing the pre-processing phase.",
    "alsoKnownAs": null,
    "text": "Zhu-Takaoka"
  },
  "Zipfian distribution": {
    "definition": "A distribution of probabilities of occurrence that follows Zipf's law.",
    "alsoKnownAs": "Yule distribution.",
    "text": "Zipfian distribution"
  },
  "Zipf's law": {
    "definition": "The probability of occurrence of words or other items starts high and tapers off.  Thus, a few occur very often while many others occur rarely.",
    "alsoKnownAs": null,
    "text": "Zipf's law"
  },
  "zipper": {
    "definition": "A data structure equivalent to a binary tree that is \"opened\" so that some node is accessible.  It consists of a pair: the current node, along with information to reconstruct the tree.  Reconstruction information is called the path or context.  A move-to-left-child operation returns the left subtree, along with a new path, which has (i) a Left value, (ii) the current node, (iii) the right subtree, and (iv) any previous path.  A similar operation moves to the right child.  A move-up operation returns a tree rebuilt from the path information and the current node, along with the previous path.",
    "alsoKnownAs": null,
    "text": "zipper"
  },
  "ZPP": {
    "definition": "The class of languages for which a membership computation by a probabilistic Turing machine halts in polynomial time with no false acceptances or rejections, but randomly some \"I don't know\" answers. \"ZPP\" means \"Zero error Probability in Polynomial\" time.",
    "alsoKnownAs": null,
    "text": "ZPP"
  }
}